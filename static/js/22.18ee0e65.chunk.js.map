{"version":3,"sources":["../../src/rpc/walletMidddleware.ts","../../src/rpc/ethRpcMiddlewares.ts","../../src/rpc/jrpcClient.ts","../../src/providers/injectedProviders/walletConnectUtils.ts","../../src/providers/injectedProviders/WalletConnectProvider.ts","../../src/providers/privateKeyProviders/ethPrivatekeyUtils.ts","../../src/providers/converter.ts","../../src/providers/utils.ts","../../src/providers/privateKeyProviders/TransactionFormatter/constants.ts","../../src/providers/privateKeyProviders/TransactionFormatter/utils.ts","../../src/providers/privateKeyProviders/TransactionFormatter/index.ts","../../src/providers/privateKeyProviders/EthereumPrivateKeyProvider.ts"],"names":["str","processTypedMessageV4","a","address","getAccounts","accounts","normalizedAccounts","_address","normalizedAddress","message","res","ethErrors","txParams","req","from","validateAndNormalizeKeyholder","processTransaction","processSignTransaction","extraParams","msgParams","data","processEthSignMessage","processTypedMessage","version","processTypedMessageV3","firstParam","secondParam","resemblesAddress","warning","processPersonalMessage","processEncryptionPublicKey","ciphertext","processDecryptMessage","getPrivateKey","createScaffoldMiddleware","eth_accounts","createAsyncMiddleware","eth_private_key","eth_coinbase","eth_sendTransaction","eth_signTransaction","eth_sign","eth_signTypedData","eth_signTypedData_v3","eth_signTypedData_v4","personal_sign","eth_getEncryptionPublicKey","eth_decrypt","mergeMiddleware","eth_syncing","createWalletMiddleware","end","next","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","createChainIdMiddleware","createProviderConfigMiddleware","connector","result","_","constructor","config","chainConfig","chainNamespace","CHAIN_NAMESPACES","EIP155","state","chainId","enable","code","method","setupProvider","onConnectorStateUpdate","switchChain","lookup","currentChainConfig","displayName","params","chainName","rpcUrls","log","error","lookupNetwork","WalletLoginError","connectedHexChainId","isHexStrict","WalletInitializationError","provider","setupEngine","providerHandlers","getProviderHandlers","ethMiddleware","createEthMiddleware","engine","createJsonRpcClient","providerFromEngine","updateProviderEngineProxy","payload","rpcUrl","connectedChainId","maybeConfig","getChainConfig","txFormatter","finalTxParams","common","unsignedEthTx","signedTx","Buffer","getProviderEngineProxy","privateToAddress","providerEngineProxy","signTx","txHash","rawMessageSig","signMessage","privKeyBuffer","sig","personalSign","privateKey","signTypedData","SignTypedDataVersion","V1","V3","V4","getEncryptionPublicKey","stripped","stripHexPrefix","buff","decrypt","encryptedData","JSON","privKey","WalletConnectProvider","providerFactory","BIG_NUMBER_WEI_MULTIPLIER","BIG_NUMBER_GWEI_MULTIPLIER","BIG_NUMBER_ETH_MULTIPLIER","toBigNumber","hex","n","dec","toNormalizedDenomination","WEI","bigNumber","GWEI","ETH","toSpecifiedDenomination","BigNumber","baseChange","conversionUtil","fromNumericBase","numberOfDecimals","convertedValue","converter","toNumericBase","fromDenomination","toDenomination","value","addHexPrefix","inputBn","BnMultiplyByFraction","targetBN","numerator","denominator","numberBN","denomBN","TRANSACTION_ENVELOPE_TYPES","TRANSACTION_TYPES","GAS_ESTIMATE_TYPES","hexWEIToDecGWEI","decGWEIToHexWEI","get","estimates","normalizedEstimates","estimatedBaseFee","normalizeGWEIDecimalNumbers","low","suggestedMaxPriorityFeePerGas","suggestedMaxFeePerGas","medium","high","referrer","referrerPolicy","mode","FastGasPrice","TransactionFormatter","providerProxy","init","getCommonConfiguration","hardfork","Hardfork","customChainParams","name","Number","networkId","defaultHardfork","Common","formatTransaction","clonedTxParams","defaultGasLimit","gasPrice","maxFeePerGas","defaultMaxPriorityFeePerGas","maxPriorityFeePerGas","defaultMaxFeePerGas","defaultGasPrice","bnLessThan","b","fetchEthGasPriceEstimate","getEIP1559Compatibility","latestBlock","supportsEIP1559","fetchGasFeeEstimateData","isLegacyGasAPICompatible","fetchEip1159GasEstimates","EIP1559APIEndpoint","gasData","gasFeeEstimates","gasEstimateType","fetchLegacyGasPriceEstimates","LegacyGasAPIEndpoint","getDefaultGasFees","estimateTxGas","gas","analyzeGasUsage","block","blockGasLimitBN","hexToBn","saferGasLimitBN","estimatedGasHex","bnToHex","blockGasLimit","addGasBuffer","multiplier","initialGasLimitBn","blockGasLimitBn","upperGasLimitBn","bufferedGasLimitBn","determineTransactionCategory","to","txCategory","transactionCategory","getDefaultGasLimit","Error","TWENTY_ONE_THOUSAND","gasLimit","chainSwitchMiddleware","updateAccount","network","parseInt","getChainSwitchMiddleware","chainSwitchHandlers","addChain","nativeCurrency","ticker","tickerName","blockExplorer","chainParams","length","wallet_addEthereumChain","wallet_switchEthereumChain","createChainSwitchMiddleware","getAccountMiddleware","accountHandlers","updatePrivatekey","createAccountMiddleware","accountParams","wallet_updateAccount","EthereumPrivateKeyProvider"],"mappings":"wgCA6BA,cAEI,OAAoB,KAAfA,SAiBH,WAYoB,GAZa,MAYb,EAZa,cAYb,EAZa,gBAYb,EAZa,wBAYb,EAZa,6BAYb,EAZa,wBAYb,EAZa,yBAYb,EAZa,qBAYb,EAZa,yBAYb,EAZa,sBAYb,EAZa,sBAWrCC,EACwB,EADxBA,sBAEI,IAAJ,EACE,MAAM,UAAN,gCAFsB,SAexB,EAfwB,gFAexB,mCAAAC,EAAA,2DACM,qBAA+BC,SAAnC,GADF,gCAGqCC,EAAjC,GAHJ,UAGUC,EAHV,OAIUC,EAA+BD,OAAcE,YAAD,OAAcA,EAAhE,iBACMC,EAA4BL,EAAlC,eAEIG,WAAJ,GAPJ,yCAQM,GARN,aAWQ,8BAA4B,CAChCG,QAAO,0DAZX,4CAfwB,kEAmCxB,yBAAAP,EAAA,sEACqBE,EAAnBM,GADF,OACEA,SADF,mDAnCwB,kEAuCxB,uGACyBN,EAAvB,GADF,OACQC,EADR,OAEEK,SAAaL,MAAbK,KAFF,4CAvCwB,kEAgDxB,0FACE,EADF,sBAEUC,gBAAN,qBAFJ,cAKQC,EAA+BC,aAAyC,CAC5EC,KAAM,IANV,SAQwBC,EAA8BH,EAAD,KAAnDA,GARF,cAQEA,OARF,gBASqBI,EAAkB,EAArCN,GATF,OASEA,SATF,mDAhDwB,kEA4DxB,0FACE,EADF,sBAEUC,gBAAN,qBAFJ,cAKQC,EAA+BC,aAAyC,CAC5EC,KAAM,IANV,SAQwBC,EAA8BH,EAAD,KAAnDA,GARF,cAQEA,OARF,gBASqBK,EAAsB,EAAzCP,GATF,OASEA,SATF,mDA5DwB,kEA4ExB,gGACE,EADF,sBAEUC,gBAAN,qBAFJ,uBAKgCI,EAA+BF,SAAF,GAA3D,GALF,cAKQV,EALR,OAMQM,EAAmBI,SAAzB,GACMK,EAAwCL,aAA9C,GACMM,EAAS,cAEbL,KAFa,EAGbM,KAAMX,IAXV,UAcqBY,EAAqB,EAAxCX,GAdF,QAcEA,SAdF,oDA5EwB,kEA6FxB,gGACE,EADF,sBAEUC,gBAAN,qBAFJ,cAKQF,EAAwBI,SAA9B,GALF,SAMgCE,EAA+BF,SAAF,GAA3D,GANF,cAMQV,EANR,OAOE,KACMe,EAAwCL,aAA9C,GACMM,EAAS,cAEbL,KAFa,EAGbM,KAAMX,IAZV,UAeqBa,EAAmB,IARtC,MAPF,QAeEZ,SAfF,oDA7FwB,kEA+GxB,8FACE,EADF,sBAEUC,gBAAN,qBAFJ,uBAKgCI,EAA+BF,SAAF,GAA3D,GALF,cAKQV,EALR,OAMQM,EAAuCI,SAA7C,GACA,KACMM,EAA4D,CAChEC,KADgE,EAEhEN,KAFgE,EAGhES,QAJF,MAPF,UAcqBC,EAAqB,IAPxC,MAPF,QAcEd,SAdF,oDA/GwB,kEAgIxB,8FACE,EADF,sBAEUC,gBAAN,qBAFJ,uBAKgCI,EAA+BF,SAAF,GAA3D,GALF,cAKQV,EALR,OAMQM,EAAuCI,SAA7C,GACA,KACMM,EAA4D,CAChEC,KADgE,EAEhEN,KAFgE,EAGhES,QAJF,MAPF,UAcqBtB,EAAqB,IAPxC,MAPF,QAcES,SAdF,oDAhIwB,kEAiJxB,oGACE,EADF,sBAEUC,gBAAN,qBAFJ,cAMQc,EAAsBZ,SAA5B,GACMa,EAAuBb,SAPkD,GASzEK,EAAwCL,aATiC,GAmB3Ec,OAAiCA,EAArC,IACE,uDACAC,gEACAA,yCACAA,oEACClB,UADDkB,2NAGAzB,IACAM,MAEAA,IACAN,KA9BJ,SAgCkBY,EAA6B,EAA7CZ,GAhCF,cAgCEA,EAhCF,OAkCQgB,EAAS,cAEbL,KAFa,EAGbM,KAAMX,IArCV,UAyCqBoB,EAAsB,EAAzCnB,GAzCF,QAyCEA,SAzCF,oDAjJwB,kEA6LxB,0FACE,EADF,sBAEUC,gBAAN,qBAFJ,uBAKgCI,EAA+BF,SAAF,GAA3D,GALF,cAKQV,EALR,gBAOqB2B,EAA0B,EAA7CpB,GAPF,OAOEA,SAPF,mDA7LwB,kEAuMxB,gGACE,EADF,sBAEUC,gBAAN,qBAFJ,cAKQoB,EAAsBlB,SAA5B,GALF,SAMgCE,EAA+BF,SAAF,GAA3D,GANF,OAMQV,EANR,OAOQe,EAAwCL,aAA9C,GACMM,EAAS,cAEbL,KAFa,EAGbM,KAAMW,IAGRrB,SAAasB,EAAqB,EAAlCtB,GAdF,4CAvMwB,kEAwNxB,oFACE,EADF,sBAEUC,gBAAN,qBAFJ,OAIED,SAAauB,EAAbvB,GAJF,4CAxNwB,sBA+NtB,OAAKwB,YAAyB,CAE9BC,aAAcC,aAjOQ,gDAkOtBC,gBAAiBD,aAlOK,gDAmOtBE,aAAcF,aAnOQ,gDAqOtBG,oBAAqBH,aArOC,gDAsOtBI,oBAAqBJ,aAtOC,gDAwOtBK,SAAUL,aAxOY,gDAyOtBM,kBAAmBN,aAzOG,gDA0OtBO,qBAAsBP,aA1OA,gDA2OtBQ,qBAAsBR,aA3OA,gDA4OtBS,cAAeT,aA5OO,gDA6OtBU,2BAA4BV,aA7ON,gDA8OtBW,YAAaX,aA9OS,kDC/CpB,cACE,MAAN,EAAM,cAAN,EAAM,gBAAN,EAAM,qBAAN,EAAM,yBAAN,EAAM,wBAAN,EAAM,sBAAN,EAAM,wBAAN,EAAM,wBAAN,EAAM,yBAAN,EAAM,2BAWJJ,EAXF,EAWEA,sBAoBF,OAlBsBgB,YAAgB,CACpCd,YAAyB,CACvBe,aAAa,IAEfC,EAAuB,CACrB9C,cACA6B,gBACAjB,qBACAK,wBACAJ,yBACAK,sBACAE,wBACAvB,wBACA4B,yBACAC,6BACAE,4BCtCA,cACG,yBACL,sBAAInB,UACFH,WACOyC,KAEFC,KAIL,cACG,yBACL,8BAAIvC,UACFH,WACOyC,KAEFC,KAIL,cAIE,MAAN,EAAM,QAAWC,EAAjB,EAAiBA,UACXC,EAAkBC,YAAsB,CAAEF,cAEzC,OAAEG,kBADiBR,YAAgB,CAACS,EAAD,GAAmCC,EAAnC,GAA1C,IAC4BJ,mBCvBd,WAA4D,GAAxC,IAAEK,EAAsC,EAAtCA,UAC7B,OACL1B,cAAa,uCAAE,oFACPtB,gBAAN,qBADa,2CAAF,qDAGbP,YAAW,uCAAE,0FACHC,EAAR,EAAQA,YACQA,EAAhB,OAFW,yCAGT,GAHS,aAKL,UAAN,0BALW,2CAAF,sDAOXW,mBAAkB,uCAAE,uGACG2C,kBAArB,GADkB,cACZC,EADY,yBAElB,GAFkB,2CAAF,wDAIlB3C,uBAAsB,uCAAE,uGACD0C,kBAArB,GADsB,cAChBC,EADgB,yBAEtB,GAFsB,2CAAF,wDAItBvC,sBAAqB,uCAAE,uGACAsC,cAAsB,CAACxC,EAAD,KAAiBA,EAA5D,OADqB,cACfyC,EADe,yBAErB,GAFqB,2CAAF,wDAIrB/B,uBAAsB,uCAAE,uGACD8B,sBAA8B,CAACxC,EAAD,KAAiBA,EAApE,OADsB,cAChByC,EADgB,yBAEtB,GAFsB,2CAAF,wDAItBtC,oBAAmB,uCAAE,uGACEqC,gBAAwB,CAACxC,EAAD,KAAiBA,EAA9D,OADmB,cACbyC,EADa,yBAEnB,GAFmB,2CAAF,wDAInBpC,sBAAqB,uCAAE,qFACfb,gBAAN,qBADqB,2CAAF,sDAGrBV,sBAAqB,uCAAE,qFACfU,gBAAN,qBADqB,2CAAF,sDAGrBmB,2BAA0B,uCAAE,qFACpBnB,gBAAN,qBAD0B,2CAAF,sDAG1BqB,sBAAwB6B,YACtB,MAAMlD,gBAAN,uB,qkBC/BA,E,kDAGJmD,WAAoI,6BAAxH,MAAwH,EAAxH,SAAwH,EAAxH,MAAiBH,EAAuG,EAAvGA,UAAuG,OAC5H,eACJI,OAAQ,CAAEC,YAAW,OAAOD,EAAP,iBAA2BE,eAAgBC,IAAiBC,UACjFC,MAAK,OAAQA,GAAR,QAAsBC,QAAtB,UAA0ChE,SAAU,OAHuE,+BAF7F,MAOrC,YAAiBsD,GAAjB,KALkI,E,iFAiBvHW,iFACN,KAAL,UADWA,sBAEH,4BAA0B,CAAE7D,QAAF,6EAAyF8D,KAAM,OAFtHD,uBAGL,mBAAmB,KAAzB,WAHWA,gCAIJ,kCAAkC,CAAEE,OAAQ,kBAJxCF,gD,wHAOAG,WAAa,GAAbA,wEACNC,KAAL,0BADWD,SAEL,iBAAN,GAFWA,gD,uHAKAE,WAA6E,GAA7EA,oFAAY,EAAiE,EAAjE,QAAZA,EAA6E,EAAtDC,cAAvBD,SACN,KAAL,UADWA,sBAEH,4BAA0B,CAAElE,QAAF,6EAAyF8D,KAAM,OAFtHI,cAGLE,EAAqB,oBAA3B,GACM,EAAN,EAAM,UAAaC,EAAnB,EAAmBA,YACnB,YAAY,CACVT,QAAS,YANAM,kBASH,iCAAiC,CACrCH,OADqC,0BAErCO,OAAQ,CAAC,CAAEV,UAASW,UAAX,EAAmCC,QAAS,QAX9CN,yDAcTO,gBAdSP,mCAkBH,iCAAiC,CACrCH,OADqC,6BAErCO,OAAQ,CAAC,CAAEV,cApBJM,8DAuBTO,IADc,MACdA,MAGA,wCAAIC,aA1BKR,uCA+BX,eAAe,CAAEX,YAAaa,KAC9B,EAhCWF,kCAgCO,mBAAmB,KAAzB,WAhCDA,kE,yHAmCGS,WAAa,GAAbA,4EACTzB,EAAL,UADcyB,sBACkBC,sBAAN,6CADZD,UAET,KAAL,SAFcA,sBAEY,4BAA0B,CAAE3E,QAAF,8BAA0C8D,KAAM,OAFtFa,UAGNf,EAAY,YAApB,YAAQA,QACFiB,EAAsBC,YAAY5B,UAAZ4B,YAA4C5B,EAA5C4B,QAAqE5B,+BAAjG,KACIU,IAAJ,EALce,sBAMNI,uBAAiFF,2CAAjFE,EAAmHnB,uBAAzH,IANYe,cAQd,YAAY,CAAEf,QAASiB,IACvB,6BAA8B,CAAEjB,YAC3BoB,KAAL,6BAAmC,WAAnC,SAVcL,kBAWd,GAXcA,iD,uHAcFM,WAAW,GAAXA,wFACNC,EAAmBC,EAAoB,CAAEjC,cAC/C,YAAY,CACVtD,SAAUsD,YAAsB,KAE5BkC,EAAgBC,EAAtB,GACMC,EAAS,IAAf,IANYL,EAOkBM,EAAoB,YAAlD,aAAQxC,EAPIkC,EAOJlC,kBACRuC,UACAA,UACMN,EAAWQ,YAAjB,GACKC,KAAL,6BAXYR,UAYN,mBAAN,GAZYA,iD,kIAeAhB,WAAsB,GAAtBA,4EACZf,6DAA+B,oGACxB,EAAL,SAD6B,sBACH0B,sBAAN,6CADS,WAE7B,EAF6B,uBAG3B,2BAH2B,+BAMuFc,SANhD,GAM9D,EANuB,EAMvB,WANuB,EAMX9B,QAA2B+B,EANhB,EAMgBA,OAEzC/F,eAAQ,IAARA,aAAoB,sBAA2BA,EAAnD,KACE,SAAY,CACVA,aAGF,sCAEIiF,EAA2Be,uBAfmC,MAiBhEA,GAAoB,kBAAxB,EAjB6B,wBAkBrBC,EAAcC,YAAerC,IAAD,OAAdqC,IAD8C,GAGlE,YAAe,CACbvC,YAAW,cAAoBK,QAApB,EAAkDhB,UAAlD,EAAqEY,eAAgBC,IAAiBC,WArBxF,UAuBrB,cAAN,GAvB2B,4CAA/BR,yDADYe,2C,4DAhGV,K,SCGN,E,kFAAA,+GAC8B8B,oBAA5B,GADF,cACQC,EADR,gBAEuBD,EAArB,yBAFF,cAEQE,EAFR,OAGQC,EAAgB,kCAA6C,CACjED,WAEIE,EAAWD,OAAmBE,SAAnBF,QAAjB,YANF,kBAOE,GAPF,4C,sBAUM,WAQL,GARmC,MAQnC,EARmC,cAQnC,EARmC,QAGlCG,EAKD,EALCA,uBAMO,OACL1G,YAAW,uCAAE,wGAAmC,CAAM2G,uCAAiBF,SAAjBE,iBADjD,UACQ,2CAAF,sDACX9E,cAAa,uCAAE,wGAFV,GAEU,2CAAF,sDACbjB,mBAAkB,uCAAE,8FACZgG,EAAsBF,IADV,sBAGV,4BAA0B,CAC9BrG,QAD8B,8BAE9B8D,KAAM,OALQ,uBAOK0C,EAAM,IAA7B,GAPkB,cAOZL,EAPY,gBAQG,UAA8C,CACjEpC,OADiE,yBAEjEO,OAAQ,CAAC,YAAY6B,WAAb,WAVQ,cAQZM,EARY,yBAYlB,GAZkB,4CAAF,wDAclBjG,uBAAsB,uCAAE,0FACM6F,IADN,sBAGd,4BAA0B,CAC9BrG,QAD8B,8BAE9B8D,KAAM,OALY,uBAOC0C,EAAM,IAA7B,GAPsB,cAOhBL,EAPgB,yBAQtB,YAAYA,WAAZ,SARsB,2CAAF,wDAUtBvF,sBAAqB,uCAAE,8FACf8F,EAAgBC,YAAW,EAAUjG,EAA3C,MADqB,kBAErB,GAFqB,2CAAF,wDAIrBU,uBAAsB,uCAAE,gGAChBwF,EAAgBR,SAAtB,OACMS,EAAMC,uBAAa,CAAEC,WAAF,EAA6BpG,KAAMD,EAAUC,OAFhD,kBAGtB,GAHsB,2CAAF,wDAKtBE,oBAAmB,uCAAE,gGACnB4D,mCACMmC,EAAgBR,SAAtB,OACMS,EAAMG,wBAAc,CAAED,WAAF,EAA6BpG,KAAMD,EAAnC,KAAmDI,QAASmG,uBAAqBC,KAHxF,kBAInB,GAJmB,2CAAF,wDAMnBnG,sBAAqB,uCAAE,gGACrB0D,qCACMmC,EAAgBR,SAAtB,OACMS,EAAMG,wBAAc,CAAED,WAAF,EAA6BpG,KAAMD,EAAnC,KAAmDI,QAASmG,uBAAqBE,KAHtF,kBAIrB,GAJqB,2CAAF,wDAMrB3H,sBAAqB,uCAAE,gGACrBiF,qCACMmC,EAAgBR,SAAtB,OACMS,EAAMG,wBAAc,CAAED,WAAF,EAA6BpG,KAAMD,EAAnC,KAAmDI,QAASmG,uBAAqBG,KAHtF,kBAIrB,GAJqB,2CAAF,wDAMrB/F,2BAA0B,uCAAE,wFAC1BoD,yCAD0B,kBAEnB4C,iCAAP,IAF0B,2CAAF,wDAI1B9F,sBAAuB,cACrBkD,oCACA,IAAM6C,EAAWC,yBAAe7G,EAAhC,MACM8G,EAAOpB,SAAb,OAEA,OADkBqB,kBAAQ,CAAEC,cAAeC,WAAWH,WAA5B,SAAwET,WAAYa,M,IDpFvGC,wB,uCAWyB,4FAI5BC,EAAkB,MAA0B,CAAExE,OAAQ,CAAEC,YAAae,EAAOf,eAJhD,SAK5BuE,gBAA8BxD,EAApC,WALkC,gCAMlC,GANkC,2C,uDEftC,IAAMyD,EAA4B,QAAlC,QACMC,EAA6B,QAAnC,OACMC,EAA4B,QAAlC,KAGMC,EAA6E,CACjFC,IAAMC,YAAD,MAA4B,oBAAwB,QAAcb,yBAAd,GAAxB,IAA+D,UADf,KAEjFc,IAAMD,YAAD,OAA2B,gBAE5BE,EAAwE,CAC5EC,IAAMC,YAAD,OAAeA,MADwD,IAE5EC,KAAOD,YAAD,OAAeA,MAFuD,IAG5EE,IAAMF,YAAD,OAAeA,WAEhBG,EAAuE,CAC3EJ,IAAMC,YAAD,OAAeA,gBAAiDI,IADM,gBAE3EH,KAAOD,YAAD,OAAeA,gBAAkDI,IAFI,gBAG3EF,IAAMF,YAAD,OAAeA,gBAAiDI,IAAjDJ,iBAEhBK,EAAuD,CAC3DV,IAAMC,YAAD,OAAOA,WAD+C,KAE3DC,IAAMD,YAAD,OAAO,0BAyBRU,EAAiB,WAGC,GADtB,MACsB,EADpBC,gBAEF,OA1BiBzE,YACX,MAAN,EAAM,QAAN,EAAM,kBAAN,EAAM,mBAAN,EAAM,gBAAN,EAAM,eAA2E0E,EAAjF,EAAiFA,iBAC7EC,EAAqCf,KAAzC,GAiBA,OAfA,IACEe,EAAiBX,KAAjBW,IAGF,IACEA,EAAiBN,KAAjBM,IAGF,IACEA,EAAkBA,OAAkDL,IAApEK,kBAGF,IACEA,EAAiBJ,KAAjBI,IAEF,EAOOC,CAAU,CACfH,qBAHF,cAIEI,cAHoB,EADtB,cAKEC,iBAJoB,EADtB,iBAMEC,eALoB,EADtB,eAOEL,iBANoB,EADsDA,iBAQ1EM,MAAOA,GAAS,OAIpB,cACSR,SAAc,EAAU,CAC7BC,gBAD6B,MAE7BI,cAF6B,MAG7BC,iBAH6B,OAI7BC,eAAgB,QAIpB,cACSP,SAAc,EAAU,CAC7BC,gBAD6B,MAE7BI,cAF6B,MAG7BC,iBAH6B,MAI7BC,eAAgB,SC/Ed,cACGE,8BAAaC,WAApB,KAGI,cACAZ,+BAAJ,GAAqC,EAC9B,gBAAcrB,yBAAd,GAAP,I,SAGckC,EAAqBC,EAAqBC,EAA+BC,GACvF,IAAMC,EAAW,gBAAjB,GACMC,EAAU,gBAAhB,GACOJ,mCAAP,GCtBK,IAEMK,GAA6B,MAA7BA,GAGC,MAGDC,GAAoB,YAApBA,GAAoB,sBAApBA,GAAoB,qBAOpBC,GAAqB,aAArBA,GAAqB,SAArBA,GAAqB,e,qkBCT5B,eAGJ,OADqBC,EADEC,EAAvB,I,SAKK,G,iFAAA,uGACmBC,YAAxB,GADK,cACCC,EADD,OAECC,EAAmB,gBAEvBC,iBAAkBC,GAA4BH,EAFvB,kBAGvBI,IAAG,SACEJ,EADF,SAEDK,8BAA+BF,GAA4BH,MAF1D,+BAGDM,sBAAuBH,GAA4BH,MAAD,yBAEpDO,OAAM,SACDP,EADC,YAEJK,8BAA+BF,GAA4BH,SAFvD,+BAGJM,sBAAuBH,GAA4BH,SAAD,yBAEpDQ,KAAI,SACCR,EADD,UAEFK,8BAA+BF,GAA4BH,OAFzD,+BAGFM,sBAAuBH,GAA4BH,OAAD,2BAlBjD,kBAqBL,GArBK,4C,+BA4BA,G,iFAAA,qGACgBD,YAAG,EAIhB,CACNU,SADM,EAENC,eAFM,6BAGNhH,OAHM,MAINiH,KAAM,SATH,cACC7H,EADD,yBAWE,CACLsH,IAAKtH,EADA,aAELyH,OAAQzH,EAFH,gBAGL0H,KAAM1H,EAAO8H,eAdV,4C,+lBC5BMC,G,WAOX7H,WAAkG,uBAAtF,IAAEgD,EAAoF,EAApFA,uBAAoF,uBANlD,MAMkD,0EAFpE,GAGvBA,KAAL,yB,+CAGE8E,WACK,YAAP,2B,yDAGIC,8FACsB,2BAA8C,CAAErH,OAAF,sBAAiCO,OAAQ,KAD7G8G,cACJ,iBADIA,gBAE6B,KAAjC,0BAFIA,OAEJ,yBAFIA,uD,iIAKAC,+FACC,KAAL,YADIA,sBACyB,UAAN,gCADnBA,gBAEmC,KAAvC,YAAM,EAFFA,EAEIhH,YAAmBT,EAFvByH,EAEuBzH,QACrB0H,EAAW,yBAA2BC,WAA3B,OAA6CA,WAA9D,OACMC,EAAoB,CACxBC,OACA7H,QAASA,gBAA4B8H,kBAFb,IAGxBC,UAAW/H,gBAA4B8H,kBAHf,IAIxBE,gBAAiBN,GARfD,kBAUGQ,WAAP,IAVIR,gD,4HAaAS,WAAiB,GAAjBA,oFACC,KAAL,YADIA,sBACyB,UAAN,gCADnBA,eAOJ,KAJMC,EACD5L,MADL,IAII4L,MAPAD,gCAQ4B,2BAAmC,CAC/D/H,OAD+D,0BAE/DO,OAAQ,CAACnE,EAAD,iBAVR2L,OAQF,QAREA,iBAaC,KAAD,sBAA6BC,EAAjC,SAbID,wBAcEC,EAAJ,qBAAwCA,EAAP,aAC7BA,EAAJ,6BAAgDA,EAAP,qBAfvCD,kBAgBF,GAhBEA,WAmBCC,EAAL,IAnBID,kCAoB4B,wBAA9B,GApBEA,SAoBIE,EApBJF,UAsBAC,cAtBAD,wBAyBFC,WAA0BA,EAA1BA,IAzBED,yBAgCM,uBAJV,GA5BIA,wBA4BE,EA5BFA,EA6BFG,SADI,EA5BFH,EA8BFI,aACsBC,EA/BpBL,EA+BFM,qBAGE,KAAJ,sBAGML,YAA4BA,EAA5BA,cAA4DA,EAAhE,sBAUMM,IAAwBN,EAA5B,eAGEA,kBAGEI,IAAgCJ,EAApC,uBAGEA,0BAGEO,IAAoBP,EAAxB,eAIEA,kBAGEA,iBAAgCA,EAApC,uBAKEA,uBAAsCA,EAAtCA,gBAjCFA,eAA8BA,EAA9BA,SAEAA,wBHlFQ,EGmFN,oBAAkDxE,yBAAlD,GAD8C,EHlFxC,EGoFN,kBAAOwE,EAAP,SAA8CxE,yBAAewE,EAA7D,UAAwFA,EAFpDQ,SHjFxC9M,mBAAcA,GAAdA,OAAiC+M,QAArC,IAAmDA,GAG5C,2BAAP,IG8E4CD,EAKlCR,EALJA,kBAqCKA,EAAP,kBAKOA,EAAP,4BACOA,EAAP,eAOEO,GAAoBP,EAApBO,UAAgDP,EAAhDO,sBAAwFP,EAA5F,eACEA,cAGFA,OAAsB,yBAA2BhC,GAAwCA,GACzFgC,UAAyB,iBAAzBA,QA/FID,kBAgGJ,GAhGIA,kCH1CQ,UG0CRA,Y,oIAmGQW,oGACY,2BAAmC,CAAE1I,OAAF,eAA0BO,OAAQ,KADjFmI,cACNR,EADMQ,yBAEL,CACLR,SAAU/B,kBAHAuC,gD,kIAOAC,sGACc,2BAAkC,CAAE3I,OAAF,uBAAkCO,OAAQ,gBAD1FoI,cACNC,EADMD,OAENE,EAAkBD,QAAxB,IAAuCA,gBAF3BD,oBAIZ,GAJYA,gD,kIAOAG,iGACP,KAAL,YADYA,sBACiB,UAAN,gCADXA,UAENC,EAAN,QAAiC,yBAE3BlJ,EAAU8H,gBAAgB,iBAAhBA,QAAhB,IAJYmB,UASN,KAAJ,oBATUA,iCAWgBE,GFxKzB,+EEwKkDC,qBAA4CpJ,UAA7F,KAXQiJ,OAWFxC,EAXEwC,OAYRI,EAAU,CACRC,gBADQ,EAERC,gBAAiBlD,IAdX4C,4BAgBH,EAhBGA,kCAiBgBO,GF/KzB,wEE+KsDC,qBAA8CzJ,UAAnG,KAjBQiJ,QAiBFxC,EAjBEwC,OAkBRI,EAAU,CACRC,gBADQ,EAERC,gBAAiBlD,IApBX4C,8BAuBF,UAAN,sDAvBQA,qFA2BgB,KAAxB,2BA3BQA,QA2BFxC,EA3BEwC,OA4BRI,EAAU,CACRC,gBADQ,EAERC,gBAAiBlD,IA9BX4C,yDAiCF,8DAAwDnI,KAA9D,UAjCQmI,iCAoCZ,GApCYA,kE,4HAuCAS,WAAiB,GAAjBA,2FAGN,KAAD,qBAA6BnN,EAA9B,UAAqD,0BAA4BA,EAA5B,cAAqDA,EAA9G,sBAHYmN,yCAIV,IAJUA,gCAQyC,KAAnD,0BARUA,mBAQJ,EARIA,EAQJ,gBAAmBH,EARfG,EAQeH,iBACrB,0BAA4BA,IAAoBlD,GAT1CqD,sBAUR,EAAQ1C,OAAQ,GAAV,aAAqE,GAArE,GAAU,8BAAiCD,EAVzC2C,EAUyC3C,uBAE7CD,IAAJ,EAZQ4C,0CAaC,CACLpB,aAAc3C,uBAAaY,EADtB,IAELiC,qBAAsB7C,uBAAaY,EAAD,MAf9BmD,mCAkBCH,IAAoBlD,GAlBrBqD,0CAqBD,CACLrB,SAAU9B,EAAiB+C,EAAF,UAtBnBI,WAwBCH,IAAoBlD,GAxBrBqD,0CA2BD,CACLrB,SAAU1C,uBAAaY,EAAiB+C,EAAlB,aA5BhBI,0DAgCV7I,gBAhCU6I,yBAmCe,KAA3B,2BAnCYA,wBAmCJrB,EAnCIqB,EAmCJrB,SAnCIqB,kBAqCL,CAAErB,SAAU1C,uBAAaY,EAAD,MArCnBmD,0D,yHAwCAC,WAAa,GAAbA,uFACNpN,EAAQ,MADqC,IAQnD,gBACOA,EAAP,oBACOA,EAAP,qBAVYoN,SAWO,2BAAmC,CAAExJ,OAAF,kBAA6BO,OAAQ,MAX/EiJ,cAWNC,EAXMD,yBAYZ,GAZYA,gD,2HAeAE,WAAe,GAAfA,6FAIS,2BAAkC,CAAE1J,OAAF,uBAAkCO,OAAQ,gBAJrFmJ,cAINC,EAJMD,OAMNE,EAAkBC,EAAQF,EAAhC,UACMG,EAAkBpE,EAAoB,KAA5C,IACIqE,EAAkBC,EAAtB,GARYN,kBAWc,mBAAxBK,GAXUL,OAWVK,EAXUL,yDAaVhJ,eAbUgJ,iCAeL,CAAEO,cAAeN,EAAjB,SAA2CI,oBAftCL,0D,iFAkBNQ,SAAY,KAAuDC,MAAgB,uDAAH,IAChFC,EAAoBP,EAA1B,GACMQ,EAAkBR,EAAxB,GACMS,EAAkBD,wBAAxB,GACME,EAAqBH,uBAJ8D,GAOzF,OAAIA,KAAJ,GAAkDJ,EAPuC,GASrFO,KAAJ,GAAmDP,EATsC,GAWlFA,EAAP,K,iFAGYQ,WAA4B,GAA5BA,gFAIN,EAAN,EAAM,KAAQC,EAAd,EAAcA,GACV1K,EAAJ,IAIInD,GAAJ,EATY4N,gBAUVE,EAAazE,GAVHuE,gDAaM,2BAAmC,CAAExK,OAAF,cAAyBO,OAAQ,eAb1EiK,OAaRzK,EAbQyK,yDAeR9J,eAfQ8J,QAmBVE,GAFoB,UAAS3K,GAA7B,QAA8CA,EAEnBkG,GAA+BA,GAnBhDuE,iCAsBL,CAAEG,oBAAF,EAAmC5K,SAtB9ByK,0D,8HAyBAI,WAAkB,GAAlBA,iGAC0B,wCAAtC,IADYA,mBACJD,EADIC,EACJD,qBAEJvO,EAAJ,IAHYwO,yCAIHxO,EAAP,KAJUwO,WAORxO,MAAeuO,IAAwB1E,GAP/B2E,qBASNxO,EAAJ,KATUwO,sBAUFC,MAAN,mEAVQD,cAO6D,KAP7DA,kBAgBHpF,uBATgE,KASnDsF,SAApB,MAhBUF,yBAmBqC,qBAnB4B,GAAjEA,wBAmBN,EAnBMA,EAmBN,cAAiBb,EAnBXa,EAmBWb,gBAGjBgB,EAAW,kBAAkBvF,uBAAlB,GAAjB,GAtBYoF,kBAuBZ,GAvBYA,iD,uoBC5RV,G,kDACJtL,WAA8G,uBAAlG,MAAkG,EAAlG,OAAUM,EAAwF,EAAxFA,MAAwF,mBACtG,CAAEL,OAAQ,CAAEC,YAAW,SAAOD,EAAP,iBAA2BE,eAAgBC,IAAiBC,UAAYC,U,iFAY1FE,iFACN,WAAL,WADWA,sBAEH,4BAA0B,CAAE7D,QAAF,4EAAwF8D,KAAM,OAFrHD,uBAGL,mBAAmB,WAAzB,YAHWA,gCAIJ,kCAAkC,CAAEE,OAAQ,kBAJxCF,gD,wHAOAG,WAAa,GAAbA,4FACL+B,EAAc,OAAyB,CAC3CM,uBAAwB,yCAEpBnB,EAAmBC,EAAoB,CAC3CY,cACA6B,UACAvB,uBAAwB,yCAEpBjB,EAAgBC,EAAtB,GACM0J,EAAwB,KAA9B,2BACMzJ,EAAS,IAXyB,IAA7BtB,EAamBuB,EAAoB,YAAlD,aAAQxC,EAbGiB,EAaHjB,kBACRuC,UACAA,UACAA,OAAY,KAAZA,wBACAA,UACMN,EAAWQ,YAAjB,GACKC,KAAL,6BAnBWzB,UAoBL+B,EAAN,OApBW/B,yBAqBL,KAAN,gBArBWA,iD,yHAwBAgL,WAAa,GAAbA,oEACN,KAAL,qBADWA,sBAC2B,4BAA0B,CAAEhP,QAAF,8BAA0C8D,KAAM,OADrGkL,uBAEe,kCAAmD,CAAEjL,OAAQ,oBAF5EiL,mBAGS1K,EAApB,WAHW0K,iCAIH,mBAAmB1K,EAAzB,YAJS0K,mBAKT,0BALSA,UAMS,kCAAqD,CAAEjL,OAAQ,iBANxEiL,0BAMPpP,SANOoP,WAKT,KALSA,UAKT,kBALSA,uD,uHAWA9K,WAAW,GAAXA,4EACN,KAAL,qBADWA,sBAC2B,4BAA0B,CAAElE,QAAF,8BAA0C8D,KAAM,OADrGI,cAELX,EAAc,oBAAoBe,EAAxC,SACA,YAAY,CACVV,QAAS,YAEX,eAAe,CAAEL,gBANNW,SAOW,kCAAmD,CAAEH,OAAQ,oBAPxEG,cAOL0D,EAPK1D,iBAQL,mBAAN,GARWA,iD,yHAWGS,yFACT,KAAL,qBADcA,sBACwB,4BAA0B,CAAE3E,QAAF,8BAA0C8D,KAAM,OADlGa,UAENf,EAAY,YAApB,YAAQA,QAFMe,sBAGMzE,8BAAN,2CAHAyE,uBAIQ,kCAAoD,CACxEZ,OADwE,cAExEO,OAAQ,KANIK,UAIRsK,EAJQtK,OASVuK,SAAQ,EAARA,MAA0BA,SAAQ,EAAtC,IATcvK,uBAS6CzE,uCAAyE+O,2CAA/E,IATvCtK,eAUV,qBAAJ,IACE,iDACA,yCAA0C,CAAEf,aAE9C,YAAY,CAAEA,YAdAe,kBAed,GAfcA,iD,4FAkBRwK,WAAwB,WACxBC,EAA4C,CAChDC,SAAQ,uCAAE,6FACF,EAAN,EAAM,UAAN,EAAM,YAAN,EAAM,UAAN,EAAM,kBAAkDC,EAAxD,EAAwDA,eACxD,WAAc,CACZ9L,eADY,SAEZI,UACA2L,QAAQ,eAAc,IAAd,oBAHI,MAIZC,YAAY,eAAc,IAAd,kBAJA,QAKZnL,YALY,EAMZzB,UAAW4B,EANC,GAOZiL,eAAe,eAAiB,IAAjB,gBAA0B,KATnC,2CAAF,sDAYRvL,YAAW,uCAAE,4FACHN,EAAR,EAAQA,QADG,SAEL,cAAiB,CAAEA,YAFd,2CAAF,uDAKPmL,E,SVhEiF,GAA/C,MAA+C,EAA/C,SAAY7K,EAAmC,EAAnCA,YAAmC,4CACzF,4FACQwL,EAA0BC,QAAZ,kBAAYA,SAAZ,OAAqBvP,SAArB,QAApB,EADF,sBAE0BF,8BAAN,wBAFpB,UAGOwP,EAAL,QAHF,sBAGkCxP,8BAAN,kCAH5B,UAIOwP,EAAD,SAAJ,IAA4BA,iBAJ9B,sBAIsExP,8BAAN,kCAJhE,UAKOwP,EAAL,eALF,sBAKyCxP,8BAAN,yCALnC,wBAOqBmP,EAAnBpP,GAPF,QAOEA,SAPF,oDADyF,kEAUzF,4FACQyP,EAA0BC,QAAZ,kBAAYA,SAAZ,OAAqBvP,SAArB,QAApB,EADF,sBAE0BF,8BAAN,mBAFpB,uBAGqBgE,EAAnBjE,GAHF,OAGEA,SAHF,mDAVyF,sBAgBzF,OAAOwB,YAAyB,CAC9BmO,wBAAyBjO,aAjB8D,gDAkBvFkO,2BAA4BlO,aAlB2D,kDUgEzDmO,CAA9B,GACA,W,kCAGMC,WAAoB,WACpBC,EAAoC,CACxCC,iBAAgB,uCAAE,4FACRlJ,EAAR,EAAQA,WADQ,SAEV,gBAAmB,CAAEA,eAFX,2CAAF,uDAKXmJ,OVhDK,SAA8D,GAAtC,IAAED,EAAoC,EAApCA,iBAAoC,4CAC5E,4FAEM,QADEE,EAA4BR,QAAZ,kBAAYA,SAAZ,OAAqBvP,SAArB,QAAtB,SACK+P,SAAL,WAFF,sBAEwCjQ,8BAAN,sBAFlC,uBAGqB+P,EAAnBhQ,GAHF,OAGEA,SAHF,mDAD4E,sBAO5E,OAAOwB,YAAyB,CAC9B2O,qBAAsBzO,aARoD,kDUgDnEuO,CAAP,O,GAnHE,K,IAAOG,yB,uCAKyB,4FAI5BvI,EAAkB,OAA+B,CAAExE,OAAQ,CAAEC,YAAae,EAAOf,eAJrD,SAK5BuE,gBAA8BxD,EAApC,SALkC,gCAMlC,GANkC,2C","file":"static/js/22.18ee0e65.chunk.js","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine, signMessage } from '@toruslabs/base-controllers';\nimport { createScaffoldMiddleware, createAsyncMiddleware, mergeMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, log, WalletLoginError, isHexStrict, WalletInitializationError, getChainConfig } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { TransactionFactory } from '@ethereumjs/tx';\nimport { personalSign, signTypedData, SignTypedDataVersion, getEncryptionPublicKey, decrypt } from '@metamask/eth-sig-util';\nimport { privateToAddress, stripHexPrefix, addHexPrefix } from 'ethereumjs-util';\nimport Common, { Hardfork } from '@ethereumjs/common';\nimport BigNumber, { BigNumber as BigNumber$1 } from 'bignumber.js';\nimport { get } from '@toruslabs/http-helpers';\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction resemblesAddress(str) {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction createWalletMiddleware(_ref) {\n  let {\n    getAccounts,\n    getPrivateKey,\n    processDecryptMessage,\n    processEncryptionPublicKey,\n    processEthSignMessage,\n    processPersonalMessage,\n    processTransaction,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4\n  } = _ref;\n\n  if (!getAccounts) {\n    throw new Error(\"opts.getAccounts is required\");\n  } //\n  // utility\n  //\n\n  /**\n   * Validates the keyholder address, and returns a normalized (i.e. lowercase)\n   * copy of it.\n   *\n   * an error\n   */\n\n\n  async function validateAndNormalizeKeyholder(address, req) {\n    if (typeof address === \"string\" && address.length > 0) {\n      // ensure address is included in provided accounts\n      const accounts = await getAccounts(req);\n      const normalizedAccounts = accounts.map(_address => _address.toLowerCase());\n      const normalizedAddress = address.toLowerCase();\n\n      if (normalizedAccounts.includes(normalizedAddress)) {\n        return normalizedAddress;\n      }\n    }\n\n    throw ethErrors.rpc.invalidParams({\n      message: \"Invalid parameters: must provide an Ethereum address.\"\n    });\n  } //\n  // account lookups\n  //\n\n\n  async function lookupAccounts(req, res) {\n    res.result = await getAccounts(req);\n  }\n\n  async function lookupDefaultAccount(req, res) {\n    const accounts = await getAccounts(req);\n    res.result = accounts[0] || null;\n  } //\n  // transaction signatures\n  //\n\n\n  async function sendTransaction(req, res) {\n    if (!processTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processTransaction(txParams, req);\n  }\n\n  async function signTransaction(req, res) {\n    if (!processSignTransaction) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const txParams = req.params[0] || {\n      from: \"\"\n    };\n    txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);\n    res.result = await processSignTransaction(txParams, req);\n  } //\n  // message signatures\n  //\n\n\n  async function ethSign(req, res) {\n    if (!processEthSignMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$4(_objectSpread$4({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processEthSignMessage(msgParams, req);\n  }\n\n  async function signTypedData(req, res) {\n    if (!processTypedMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const message = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const version = \"V1\";\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$4(_objectSpread$4({}, extraParams), {}, {\n      from: address,\n      data: message\n    });\n\n    res.result = await processTypedMessage(msgParams, req, version);\n  }\n\n  async function signTypedDataV3(req, res) {\n    if (!processTypedMessageV3) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V3\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV3(msgParams, req, version);\n  }\n\n  async function signTypedDataV4(req, res) {\n    if (!processTypedMessageV4) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    const message = req.params[1];\n    const version = \"V4\";\n    const msgParams = {\n      data: message,\n      from: address,\n      version\n    };\n    res.result = await processTypedMessageV4(msgParams, req, version);\n  }\n\n  async function personalSign(req, res) {\n    if (!processPersonalMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    } // process normally\n\n\n    const firstParam = req.params[0];\n    const secondParam = req.params[1]; // non-standard \"extraParams\" to be appended to our \"msgParams\" obj\n\n    const extraParams = req.params[2] || {}; // We initially incorrectly ordered these parameters.\n    // To gracefully respect users who adopted this API early,\n    // we are currently gracefully recovering from the wrong param order\n    // when it is clearly identifiable.\n    //\n    // That means when the first param is definitely an address,\n    // and the second param is definitely not, but is hex.\n\n    let address, message;\n\n    if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {\n      let warning = \"The eth_personalSign method requires params ordered \";\n      warning += \"[message, address]. This was previously handled incorrectly, \";\n      warning += \"and has been corrected automatically. \";\n      warning += \"Please switch this param order for smooth behavior in the future.\";\n      res.warning = warning;\n      address = firstParam;\n      message = secondParam;\n    } else {\n      message = firstParam;\n      address = secondParam;\n    }\n\n    address = await validateAndNormalizeKeyholder(address, req);\n\n    const msgParams = _objectSpread$4(_objectSpread$4({}, extraParams), {}, {\n      from: address,\n      data: message\n    }); // eslint-disable-next-line require-atomic-updates\n\n\n    res.result = await processPersonalMessage(msgParams, req);\n  }\n\n  async function encryptionPublicKey(req, res) {\n    if (!processEncryptionPublicKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const address = await validateAndNormalizeKeyholder(req.params[0], req);\n    res.result = await processEncryptionPublicKey(address, req);\n  }\n\n  async function decryptMessage(req, res) {\n    if (!processDecryptMessage) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    const ciphertext = req.params[0];\n    const address = await validateAndNormalizeKeyholder(req.params[1], req);\n    const extraParams = req.params[2] || {};\n\n    const msgParams = _objectSpread$4(_objectSpread$4({}, extraParams), {}, {\n      from: address,\n      data: ciphertext\n    });\n\n    res.result = processDecryptMessage(msgParams, req);\n  }\n\n  async function fetchPrivateKey(req, res) {\n    if (!getPrivateKey) {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n\n    res.result = getPrivateKey(req);\n  }\n\n  return createScaffoldMiddleware({\n    // account lookups\n    eth_accounts: createAsyncMiddleware(lookupAccounts),\n    eth_private_key: createAsyncMiddleware(fetchPrivateKey),\n    eth_coinbase: createAsyncMiddleware(lookupDefaultAccount),\n    // tx signatures\n    eth_sendTransaction: createAsyncMiddleware(sendTransaction),\n    eth_signTransaction: createAsyncMiddleware(signTransaction),\n    // message signatures\n    eth_sign: createAsyncMiddleware(ethSign),\n    eth_signTypedData: createAsyncMiddleware(signTypedData),\n    eth_signTypedData_v3: createAsyncMiddleware(signTypedDataV3),\n    eth_signTypedData_v4: createAsyncMiddleware(signTypedDataV4),\n    personal_sign: createAsyncMiddleware(personalSign),\n    eth_getEncryptionPublicKey: createAsyncMiddleware(encryptionPublicKey),\n    eth_decrypt: createAsyncMiddleware(decryptMessage)\n  });\n}\n\nfunction createEthMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processSignTransaction,\n    processEthSignMessage,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  } = providerHandlers;\n  const ethMiddleware = mergeMiddleware([createScaffoldMiddleware({\n    eth_syncing: false\n  }), createWalletMiddleware({\n    getAccounts,\n    getPrivateKey,\n    processTransaction,\n    processEthSignMessage,\n    processSignTransaction,\n    processTypedMessage,\n    processTypedMessageV3,\n    processTypedMessageV4,\n    processPersonalMessage,\n    processEncryptionPublicKey,\n    processDecryptMessage\n  })]);\n  return ethMiddleware;\n}\nfunction createChainSwitchMiddleware(_ref) {\n  let {\n    addChain,\n    switchChain\n  } = _ref;\n\n  async function addNewChain(req, res) {\n    var _req$params;\n\n    const chainParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chain params\");\n    if (!chainParams.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n    if (!chainParams.rpcUrls || chainParams.rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n    if (!chainParams.nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n    res.result = await addChain(chainParams);\n  }\n\n  async function updateChain(req, res) {\n    var _req$params2;\n\n    const chainParams = (_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.length ? req.params[0] : undefined;\n    if (!chainParams) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n    res.result = await switchChain(chainParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_addEthereumChain: createAsyncMiddleware(addNewChain),\n    wallet_switchEthereumChain: createAsyncMiddleware(updateChain)\n  });\n}\nfunction createAccountMiddleware(_ref2) {\n  let {\n    updatePrivatekey\n  } = _ref2;\n\n  async function updateAccount(req, res) {\n    var _req$params3;\n\n    const accountParams = (_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.length ? req.params[0] : undefined;\n    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n    res.result = await updatePrivatekey(accountParams);\n  }\n\n  return createScaffoldMiddleware({\n    wallet_updateAccount: createAsyncMiddleware(updateAccount)\n  });\n} // #endregion account middlewares\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"eth_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction getProviderHandlers$1(_ref) {\n  let {\n    connector\n  } = _ref;\n  return {\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getAccounts: async _ => {\n      const {\n        accounts\n      } = connector;\n\n      if (accounts && accounts.length) {\n        return accounts;\n      }\n\n      throw new Error(\"Failed to get accounts\");\n    },\n    processTransaction: async (txParams, _) => {\n      const result = await connector.sendTransaction(txParams);\n      return result;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const result = await connector.signTransaction(txParams);\n      return result;\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const result = await connector.signMessage([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const result = await connector.signPersonalMessage([msgParams.data, msgParams.from]);\n      return result;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      const result = await connector.signTypedData([msgParams.from, msgParams.data]);\n      return result;\n    },\n    processTypedMessageV3: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processTypedMessageV4: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processEncryptionPublicKey: async _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    processDecryptMessage: _ => {\n      throw ethErrors.rpc.methodNotSupported();\n    }\n  };\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass WalletConnectProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state,\n      connector\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$3(_objectSpread$3({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state: _objectSpread$3(_objectSpread$3({}, state || {}), {}, {\n        chainId: \"loading\",\n        accounts: []\n      })\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    this.connector = connector || null;\n  }\n\n  async enable() {\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    await this.setupProvider(this.connector);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(connector) {\n    this.onConnectorStateUpdate(connector);\n    await this.setupEngine(connector);\n  }\n\n  async switchChain(_ref2) {\n    let {\n      chainId,\n      lookup = true\n    } = _ref2;\n    if (!this.connector) throw ethErrors.provider.custom({\n      message: \"Connector is not initialized, pass wallet connect connector in constructor\",\n      code: 4902\n    });\n    const currentChainConfig = this.getChainConfig(chainId);\n    const {\n      rpcTarget,\n      displayName\n    } = currentChainConfig;\n    this.update({\n      chainId: \"loading\"\n    });\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_addEthereumChain\",\n        params: [{\n          chainId,\n          chainName: displayName,\n          rpcUrls: [rpcTarget]\n        }]\n      });\n    } catch (error) {\n      log.error(error);\n    }\n\n    try {\n      await this.connector.sendCustomRequest({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId\n        }]\n      });\n    } catch (error) {\n      log.error(error); // ignore this error because metamask & others return provider.result as null\n      // wallet connect thinks this is wrong\n\n      if (error.message !== \"JSON RPC response format is invalid\") {\n        throw error;\n      }\n    }\n\n    this.configure({\n      chainConfig: currentChainConfig\n    });\n    if (lookup) await this.lookupNetwork(this.connector);\n  }\n\n  async lookupNetwork(connector) {\n    if (!connector.connected) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedHexChainId = isHexStrict(connector.chainId.toString()) ? connector.chainId : \"0x\".concat(connector.chainId.toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return connectedHexChainId;\n  }\n\n  async setupEngine(connector) {\n    const providerHandlers = getProviderHandlers$1({\n      connector\n    });\n    this.update({\n      accounts: connector.accounts || []\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(connector);\n  }\n\n  async onConnectorStateUpdate(connector) {\n    connector.on(\"session_update\", async (error, payload) => {\n      if (!this.provider) throw WalletLoginError.notConnectedError(\"Wallet connect connector is not connected\");\n\n      if (error) {\n        this.provider.emit(\"error\", error);\n        return;\n      }\n\n      const {\n        accounts,\n        chainId: connectedChainId,\n        rpcUrl\n      } = payload.params[0]; // Check if accounts changed and trigger event\n\n      if (accounts !== null && accounts !== void 0 && accounts.length && this.state.accounts[0] !== accounts[0]) {\n        this.update({\n          accounts\n        }); // await this.setupEngine(connector);\n\n        this.provider.emit(\"accountsChanged\", accounts);\n      }\n\n      const connectedHexChainId = \"0x\".concat(connectedChainId.toString(16)); // Check if chainId changed and trigger event\n\n      if (connectedChainId && this.state.chainId !== connectedHexChainId) {\n        const maybeConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, connectedChainId) || {}; // Handle rpcUrl update\n\n        this.configure({\n          chainConfig: _objectSpread$3(_objectSpread$3({}, maybeConfig), {}, {\n            chainId: connectedHexChainId,\n            rpcTarget: rpcUrl,\n            chainNamespace: CHAIN_NAMESPACES.EIP155\n          })\n        });\n        await this.setupEngine(connector);\n      }\n    });\n  }\n\n}\n\n_defineProperty(WalletConnectProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new WalletConnectProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.connector);\n  return providerFactory;\n});\n\nasync function signTx(txParams, privKey, txFormatter) {\n  const finalTxParams = await txFormatter.formatTransaction(txParams);\n  const common = await txFormatter.getCommonConfiguration();\n  const unsignedEthTx = TransactionFactory.fromTxData(finalTxParams, {\n    common\n  });\n  const signedTx = unsignedEthTx.sign(Buffer.from(privKey, \"hex\")).serialize();\n  return signedTx;\n}\n\nfunction getProviderHandlers(_ref) {\n  let {\n    txFormatter,\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n  return {\n    getAccounts: async _ => [\"0x\".concat(privateToAddress(Buffer.from(privKey, \"hex\")).toString(\"hex\"))],\n    getPrivateKey: async _ => privKey,\n    processTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      const txHash = await providerEngineProxy.request({\n        method: \"eth_sendRawTransaction\",\n        params: [\"0x\".concat(signedTx.toString(\"hex\"))]\n      });\n      return txHash;\n    },\n    processSignTransaction: async (txParams, _) => {\n      const providerEngineProxy = getProviderEngineProxy();\n      if (!providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const signedTx = await signTx(txParams, privKey, txFormatter);\n      return \"0x\".concat(signedTx.toString(\"hex\"));\n    },\n    processEthSignMessage: async (msgParams, _) => {\n      const rawMessageSig = signMessage(privKey, msgParams.data);\n      return rawMessageSig;\n    },\n    processPersonalMessage: async (msgParams, _) => {\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = personalSign({\n        privateKey: privKeyBuffer,\n        data: msgParams.data\n      });\n      return sig;\n    },\n    processTypedMessage: async (msgParams, _) => {\n      log.debug(\"processTypedMessage\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V1\n      });\n      return sig;\n    },\n    processTypedMessageV3: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV3\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V3\n      });\n      return sig;\n    },\n    processTypedMessageV4: async (msgParams, _) => {\n      log.debug(\"processTypedMessageV4\", msgParams);\n      const privKeyBuffer = Buffer.from(privKey, \"hex\");\n      const sig = signTypedData({\n        privateKey: privKeyBuffer,\n        data: msgParams.data,\n        version: SignTypedDataVersion.V4\n      });\n      return sig;\n    },\n    processEncryptionPublicKey: async (address, _) => {\n      log.info(\"processEncryptionPublicKey\", address);\n      return getEncryptionPublicKey(privKey);\n    },\n    processDecryptMessage: (msgParams, _) => {\n      log.info(\"processDecryptMessage\", msgParams);\n      const stripped = stripHexPrefix(msgParams.data);\n      const buff = Buffer.from(stripped, \"hex\");\n      const decrypted = decrypt({\n        encryptedData: JSON.parse(buff.toString(\"utf8\")),\n        privateKey: privKey\n      });\n      return decrypted;\n    }\n  };\n}\n\nconst BIG_NUMBER_WEI_MULTIPLIER = new BigNumber(\"1e18\");\nconst BIG_NUMBER_GWEI_MULTIPLIER = new BigNumber(\"1e9\");\nconst BIG_NUMBER_ETH_MULTIPLIER = new BigNumber(\"1\"); // Setter Maps\n\nconst toBigNumber = {\n  hex: n => typeof n === \"string\" ? new BigNumber(stripHexPrefix(n), 16) : new BigNumber(n, 16),\n  dec: n => new BigNumber(n, 10)\n};\nconst toNormalizedDenomination = {\n  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),\n  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),\n  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)\n};\nconst toSpecifiedDenomination = {\n  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).dp(0, BigNumber.ROUND_HALF_UP),\n  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP),\n  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).dp(9, BigNumber.ROUND_HALF_UP)\n};\nconst baseChange = {\n  hex: n => n.toString(16),\n  dec: n => new BigNumber(n).toString(10)\n};\n\nconst converter = params => {\n  const {\n    value,\n    fromNumericBase,\n    fromDenomination,\n    toNumericBase,\n    toDenomination,\n    numberOfDecimals\n  } = params;\n  let convertedValue = toBigNumber[fromNumericBase](value);\n\n  if (fromDenomination) {\n    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);\n  }\n\n  if (toDenomination) {\n    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);\n  }\n\n  if (numberOfDecimals) {\n    convertedValue = convertedValue.dp(numberOfDecimals, BigNumber.ROUND_HALF_DOWN);\n  }\n\n  if (toNumericBase) {\n    convertedValue = baseChange[toNumericBase](convertedValue);\n  }\n\n  return convertedValue;\n};\n\nconst conversionUtil = (value, _ref) => {\n  let {\n    fromNumericBase = \"hex\",\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals\n  } = _ref;\n  return converter({\n    fromNumericBase,\n    toNumericBase,\n    fromDenomination,\n    toDenomination,\n    numberOfDecimals,\n    value: value || \"0\"\n  });\n};\n\nfunction decGWEIToHexWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"dec\",\n    toNumericBase: \"hex\",\n    fromDenomination: \"GWEI\",\n    toDenomination: \"WEI\"\n  });\n}\n\nfunction hexWEIToDecGWEI(decGWEI) {\n  return conversionUtil(decGWEI, {\n    fromNumericBase: \"hex\",\n    toNumericBase: \"dec\",\n    fromDenomination: \"WEI\",\n    toDenomination: \"GWEI\"\n  });\n}\n\nfunction bnLessThan(a, b) {\n  if (a === null || a === undefined || b === null || b === undefined) {\n    return null;\n  }\n\n  return new BigNumber$1(a, 10).lt(b, 10);\n}\nfunction bnToHex(inputBn) {\n  return addHexPrefix(inputBn.toString(16));\n}\nfunction hexToBn(inputHex) {\n  if (BigNumber$1.isBigNumber(inputHex)) return inputHex;\n  return new BigNumber$1(stripHexPrefix(inputHex), 16);\n}\nfunction BnMultiplyByFraction(targetBN, numerator, denominator) {\n  const numberBN = new BigNumber$1(numerator);\n  const denomBN = new BigNumber$1(denominator);\n  return targetBN.multipliedBy(numberBN).dividedBy(denomBN);\n}\n\nconst LegacyGasAPIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/gasPrices\";\nconst EIP1559APIEndpoint = \"https://gas-api.metaswap.codefi.network/networks/<chain_id>/suggestedGasFees\";\nconst TRANSACTION_ENVELOPE_TYPES = {\n  LEGACY: \"0x0\",\n  ACCESS_LIST: \"0x1\",\n  FEE_MARKET: \"0x2\"\n};\nconst TRANSACTION_TYPES = {\n  SENT_ETHER: \"sentEther\",\n  CONTRACT_INTERACTION: \"contractInteraction\",\n  DEPLOY_CONTRACT: \"contractDeployment\",\n  STANDARD_TRANSACTION: \"transaction\"\n};\nconst GAS_ESTIMATE_TYPES = {\n  FEE_MARKET: \"fee-market\",\n  LEGACY: \"legacy\",\n  ETH_GASPRICE: \"eth_gasPrice\",\n  NONE: \"none\"\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction normalizeGWEIDecimalNumbers(n) {\n  const numberAsWEIHex = decGWEIToHexWEI(n);\n  const numberAsGWEI = hexWEIToDecGWEI(numberAsWEIHex);\n  return numberAsGWEI;\n}\nasync function fetchEip1159GasEstimates(url) {\n  const estimates = await get(url);\n\n  const normalizedEstimates = _objectSpread$2(_objectSpread$2({}, estimates), {}, {\n    estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),\n    low: _objectSpread$2(_objectSpread$2({}, estimates.low), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas)\n    }),\n    medium: _objectSpread$2(_objectSpread$2({}, estimates.medium), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas)\n    }),\n    high: _objectSpread$2(_objectSpread$2({}, estimates.high), {}, {\n      suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas),\n      suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas)\n    })\n  });\n\n  return normalizedEstimates;\n}\n/**\n * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium\n * high values from that API.\n */\n\nasync function fetchLegacyGasPriceEstimates(url) {\n  const result = await get(url, {\n    referrer: url,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n    method: \"GET\",\n    mode: \"cors\"\n  });\n  return {\n    low: result.SafeGasPrice,\n    medium: result.ProposeGasPrice,\n    high: result.FastGasPrice\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TransactionFormatter {\n  constructor(_ref) {\n    let {\n      getProviderEngineProxy\n    } = _ref;\n\n    _defineProperty(this, \"chainConfig\", null);\n\n    _defineProperty(this, \"getProviderEngineProxy\", void 0);\n\n    _defineProperty(this, \"isEIP1559Compatible\", false);\n\n    this.getProviderEngineProxy = getProviderEngineProxy;\n  }\n\n  get providerProxy() {\n    return this.getProviderEngineProxy();\n  }\n\n  async init() {\n    this.chainConfig = await this.providerProxy.request({\n      method: \"eth_provider_config\",\n      params: []\n    });\n    this.isEIP1559Compatible = await this.getEIP1559Compatibility();\n  }\n\n  async getCommonConfiguration() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const {\n      displayName: name,\n      chainId\n    } = this.chainConfig;\n    const hardfork = this.isEIP1559Compatible ? Hardfork.London : Hardfork.Berlin;\n    const customChainParams = {\n      name,\n      chainId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      networkId: chainId === \"loading\" ? 0 : Number.parseInt(chainId, 16),\n      defaultHardfork: hardfork\n    };\n    return Common.custom(customChainParams);\n  }\n\n  async formatTransaction(txParams) {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n\n    const clonedTxParams = _objectSpread$1({}, txParams);\n\n    if (clonedTxParams.nonce === undefined) clonedTxParams.nonce = await this.providerProxy.request({\n      method: \"eth_getTransactionCount\",\n      params: [txParams.from, \"latest\"]\n    });\n\n    if (!this.isEIP1559Compatible && clonedTxParams.gasPrice) {\n      if (clonedTxParams.maxFeePerGas) delete clonedTxParams.maxFeePerGas;\n      if (clonedTxParams.maxPriorityFeePerGas) delete clonedTxParams.maxPriorityFeePerGas;\n      return clonedTxParams;\n    }\n\n    if (!clonedTxParams.gas) {\n      const defaultGasLimit = await this.getDefaultGasLimit(clonedTxParams);\n\n      if (defaultGasLimit) {\n        clonedTxParams.gasLimit = defaultGasLimit;\n      }\n    } else {\n      clonedTxParams.gasLimit = clonedTxParams.gas;\n    }\n\n    const {\n      gasPrice: defaultGasPrice,\n      maxFeePerGas: defaultMaxFeePerGas,\n      maxPriorityFeePerGas: defaultMaxPriorityFeePerGas\n    } = await this.getDefaultGasFees(clonedTxParams);\n\n    if (this.isEIP1559Compatible) {\n      // If the dapp has suggested a gas price, but no maxFeePerGas or maxPriorityFeePerGas\n      //  then we set maxFeePerGas and maxPriorityFeePerGas to the suggested gasPrice.\n      if (clonedTxParams.gasPrice && !clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n        clonedTxParams.maxFeePerGas = clonedTxParams.gasPrice;\n        clonedTxParams.maxPriorityFeePerGas = bnLessThan(typeof defaultMaxPriorityFeePerGas === \"string\" ? stripHexPrefix(defaultMaxPriorityFeePerGas) : defaultMaxPriorityFeePerGas, typeof clonedTxParams.gasPrice === \"string\" ? stripHexPrefix(clonedTxParams.gasPrice) : clonedTxParams.gasPrice) ? defaultMaxPriorityFeePerGas : clonedTxParams.gasPrice;\n      } else {\n        if (defaultMaxFeePerGas && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, then we set maxFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxFeePerGas = defaultMaxFeePerGas;\n        }\n\n        if (defaultMaxPriorityFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, then we set maxPriorityFeePerGas\n          // with the one returned by the gasFeeController, if that is available.\n          clonedTxParams.maxPriorityFeePerGas = defaultMaxPriorityFeePerGas;\n        }\n\n        if (defaultGasPrice && !clonedTxParams.maxFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxFeePerGas, and no maxFeePerGas is available\n          // then we set maxFeePerGas to the defaultGasPrice, assuming it is\n          // available.\n          clonedTxParams.maxFeePerGas = defaultGasPrice;\n        }\n\n        if (clonedTxParams.maxFeePerGas && !clonedTxParams.maxPriorityFeePerGas) {\n          // If the dapp has not set the gasPrice or the maxPriorityFeePerGas, and no maxPriorityFeePerGas is\n          // available  then we set maxPriorityFeePerGas to\n          // clonedTxParams.maxFeePerGas, which will either be the gasPrice from the controller, the maxFeePerGas\n          // set by the dapp, or the maxFeePerGas from the controller.\n          clonedTxParams.maxPriorityFeePerGas = clonedTxParams.maxFeePerGas;\n        }\n      } // We remove the gasPrice param entirely when on an eip1559 compatible network\n\n\n      delete clonedTxParams.gasPrice;\n    } else {\n      // We ensure that maxFeePerGas and maxPriorityFeePerGas are not in the transaction params\n      // when not on a EIP1559 compatible network\n      delete clonedTxParams.maxPriorityFeePerGas;\n      delete clonedTxParams.maxFeePerGas;\n    } // If we have gotten to this point, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas are\n    // set on txParams, it means that either we are on a non-EIP1559 network and the dapp didn't suggest\n    // a gas price, or we are on an EIP1559 network, and none of gasPrice, maxPriorityFeePerGas or maxFeePerGas\n    // were available from either the dapp or the network.\n\n\n    if (defaultGasPrice && !clonedTxParams.gasPrice && !clonedTxParams.maxPriorityFeePerGas && !clonedTxParams.maxFeePerGas) {\n      clonedTxParams.gasPrice = defaultGasPrice;\n    }\n\n    clonedTxParams.type = this.isEIP1559Compatible ? TRANSACTION_ENVELOPE_TYPES.FEE_MARKET : TRANSACTION_ENVELOPE_TYPES.LEGACY;\n    clonedTxParams.chainId = this.chainConfig.chainId;\n    return clonedTxParams;\n  }\n\n  async fetchEthGasPriceEstimate() {\n    const gasPrice = await this.providerProxy.request({\n      method: \"eth_gasPrice\",\n      params: []\n    });\n    return {\n      gasPrice: hexWEIToDecGWEI(gasPrice).toString()\n    };\n  }\n\n  async getEIP1559Compatibility() {\n    const latestBlock = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    });\n    const supportsEIP1559 = latestBlock && latestBlock.baseFeePerGas !== undefined;\n    return !!supportsEIP1559;\n  }\n\n  async fetchGasFeeEstimateData() {\n    if (!this.chainConfig) throw new Error(\"Chain config not initialized\");\n    const isLegacyGasAPICompatible = this.chainConfig.chainId === \"0x1\";\n    const chainId = Number.parseInt(this.chainConfig.chainId, 16);\n    let gasData;\n\n    try {\n      if (this.isEIP1559Compatible) {\n        // TODO: kovan is not working due to a bug in metamask api\n        const estimates = await fetchEip1159GasEstimates(EIP1559APIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.FEE_MARKET\n        };\n      } else if (isLegacyGasAPICompatible) {\n        const estimates = await fetchLegacyGasPriceEstimates(LegacyGasAPIEndpoint.replace(\"<chain_id>\", \"\".concat(chainId)));\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.LEGACY\n        };\n      } else {\n        throw new Error(\"Main gas fee/price estimation failed. Use fallback\");\n      }\n    } catch (e) {\n      try {\n        const estimates = await this.fetchEthGasPriceEstimate();\n        gasData = {\n          gasFeeEstimates: estimates,\n          gasEstimateType: GAS_ESTIMATE_TYPES.ETH_GASPRICE\n        };\n      } catch (error) {\n        throw new Error(\"Gas fee/price estimation failed. Message: \".concat(error.message));\n      }\n    }\n\n    return gasData;\n  }\n\n  async getDefaultGasFees(txParams) {\n    if (!this.isEIP1559Compatible && txParams.gasPrice || this.isEIP1559Compatible && txParams.maxFeePerGas && txParams.maxPriorityFeePerGas) {\n      return {};\n    }\n\n    try {\n      const {\n        gasFeeEstimates,\n        gasEstimateType\n      } = await this.fetchGasFeeEstimateData();\n\n      if (this.isEIP1559Compatible && gasEstimateType === GAS_ESTIMATE_TYPES.FEE_MARKET) {\n        const {\n          medium: {\n            suggestedMaxPriorityFeePerGas,\n            suggestedMaxFeePerGas\n          } = {}\n        } = gasFeeEstimates;\n\n        if (suggestedMaxPriorityFeePerGas && suggestedMaxFeePerGas) {\n          return {\n            maxFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxFeePerGas)),\n            maxPriorityFeePerGas: addHexPrefix(decGWEIToHexWEI(suggestedMaxPriorityFeePerGas))\n          };\n        }\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.LEGACY) {\n        // The LEGACY type includes low, medium and high estimates of\n        // gas price values.\n        return {\n          gasPrice: decGWEIToHexWEI(gasFeeEstimates.medium)\n        };\n      } else if (gasEstimateType === GAS_ESTIMATE_TYPES.ETH_GASPRICE) {\n        // The ETH_GASPRICE type just includes a single gas price property,\n        // which we can assume was retrieved from eth_gasPrice\n        return {\n          gasPrice: addHexPrefix(decGWEIToHexWEI(gasFeeEstimates.gasPrice))\n        };\n      }\n    } catch (error) {\n      log.error(error);\n    }\n\n    const {\n      gasPrice\n    } = await this.fetchEthGasPriceEstimate();\n    return {\n      gasPrice: addHexPrefix(decGWEIToHexWEI(gasPrice))\n    };\n  }\n\n  async estimateTxGas(txMeta) {\n    const txParams = _objectSpread$1({}, txMeta); // `eth_estimateGas` can fail if the user has insufficient balance for the\n    // value being sent, or for the gas cost. We don't want to check their\n    // balance here, we just want the gas estimate. The gas price is removed\n    // to skip those balance checks. We check balance elsewhere. We also delete\n    // maxFeePerGas and maxPriorityFeePerGas to support EIP-1559 txs.\n\n\n    delete txParams.gasPrice;\n    delete txParams.maxFeePerGas;\n    delete txParams.maxPriorityFeePerGas;\n    const gas = await this.providerProxy.request({\n      method: \"eth_estimateGas\",\n      params: [txParams]\n    });\n    return gas;\n  }\n\n  async analyzeGasUsage(txMeta) {\n    const block = await this.providerProxy.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", false]\n    }); // fallback to block gasLimit\n\n    const blockGasLimitBN = hexToBn(block.gasLimit);\n    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);\n    let estimatedGasHex = bnToHex(saferGasLimitBN);\n\n    try {\n      estimatedGasHex = await this.estimateTxGas(txMeta);\n    } catch (error) {\n      log.warn(error);\n    }\n\n    return {\n      blockGasLimit: block.gasLimit,\n      estimatedGasHex\n    };\n  }\n\n  addGasBuffer(initialGasLimitHex, blockGasLimitHex) {\n    let multiplier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.5;\n    const initialGasLimitBn = hexToBn(initialGasLimitHex);\n    const blockGasLimitBn = hexToBn(blockGasLimitHex);\n    const upperGasLimitBn = blockGasLimitBn.multipliedBy(0.9).dp(0, 1);\n    const bufferedGasLimitBn = initialGasLimitBn.multipliedBy(multiplier).dp(0, 1); // if initialGasLimit is above blockGasLimit, dont modify it\n\n    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn); // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit\n\n    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn); // otherwise use blockGasLimit\n\n    return bnToHex(upperGasLimitBn);\n  }\n\n  async determineTransactionCategory(txParameters) {\n    const {\n      data,\n      to\n    } = txParameters;\n    let code = \"\";\n    let txCategory;\n\n    if (data && !to) {\n      txCategory = TRANSACTION_TYPES.DEPLOY_CONTRACT;\n    } else {\n      try {\n        code = await this.providerProxy.request({\n          method: \"eth_getCode\",\n          params: [to, \"latest\"]\n        });\n      } catch (error) {\n        log.warn(error);\n      }\n\n      const codeIsEmpty = !code || code === \"0x\" || code === \"0x0\";\n      txCategory = codeIsEmpty ? TRANSACTION_TYPES.SENT_ETHER : TRANSACTION_TYPES.CONTRACT_INTERACTION;\n    }\n\n    return {\n      transactionCategory: txCategory,\n      code\n    };\n  }\n\n  async getDefaultGasLimit(txParams) {\n    const {\n      transactionCategory\n    } = await this.determineTransactionCategory(_objectSpread$1({}, txParams));\n\n    if (txParams.gas) {\n      return txParams.gas;\n    }\n\n    if (txParams.to && transactionCategory === TRANSACTION_TYPES.SENT_ETHER) {\n      // if there's data in the params, but there's no contract code, it's not a valid transaction\n      if (txParams.data) {\n        throw Error(\"TxGasUtil - Trying to call a function on a non-contract address\");\n      }\n\n      const TWENTY_ONE_THOUSAND = 21000; // This is a standard ether simple send, gas requirement is exactly 21k\n\n      return addHexPrefix(TWENTY_ONE_THOUSAND.toString(16));\n    }\n\n    const {\n      blockGasLimit,\n      estimatedGasHex\n    } = await this.analyzeGasUsage(txParams); // add additional gas buffer to our estimation for safety\n\n    const gasLimit = this.addGasBuffer(addHexPrefix(estimatedGasHex), blockGasLimit);\n    return gasLimit;\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass EthereumPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.EIP155\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const txFormatter = new TransactionFormatter({\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const providerHandlers = getProviderHandlers({\n      txFormatter,\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const ethMiddleware = createEthMiddleware(providerHandlers);\n    const chainSwitchMiddleware = this.getChainSwitchMiddleware();\n    const engine = new JRPCEngine(); // Not a partial anymore because of checks in ctor\n\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(ethMiddleware);\n    engine.push(chainSwitchMiddleware);\n    engine.push(this.getAccountMiddleware());\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await txFormatter.init();\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"eth_accounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"eth_private_key\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    if (!chainId) throw ethErrors.rpc.invalidParams(\"chainId is required while lookupNetwork\");\n    const network = await this._providerEngineProxy.request({\n      method: \"net_version\",\n      params: []\n    });\n    if (parseInt(chainId, 16) !== parseInt(network, 10)) throw ethErrors.provider.chainDisconnected(\"Invalid network, net_version is: \".concat(network));\n\n    if (this.state.chainId !== chainId) {\n      this._providerEngineProxy.emit(\"chainChanged\", chainId);\n\n      this._providerEngineProxy.emit(\"connect\", {\n        chainId\n      });\n    }\n\n    this.update({\n      chainId\n    });\n    return network;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addChain: async params => {\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = params;\n        this.addChain({\n          chainNamespace: \"eip155\",\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"ETH\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Ether\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchChain: async params => {\n        const {\n          chainId\n        } = params;\n        await this.switchChain({\n          chainId\n        });\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async params => {\n        const {\n          privateKey\n        } = params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(EthereumPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new EthereumPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nexport { EthereumPrivateKeyProvider, WalletConnectProvider };\n//# sourceMappingURL=ethereumProvider.esm.js.map\n",null,null,null,null,null,null,null,null,null,null,null],"sourceRoot":""}