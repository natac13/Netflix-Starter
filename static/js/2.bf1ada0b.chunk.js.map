{"version":3,"sources":["../node_modules/bs58/index.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/text-encoding-utf-8/lib/encoding.lib.mjs","../node_modules/rpc-websockets/dist/index.browser.js","../node_modules/jayson/lib/client/browser/index.js","../../src/utils.ts","../../src/error.ts","../../src/struct.ts","../../src/structs/utilities.ts","../../src/structs/types.ts","../node_modules/@babel/runtime/helpers/esm/toArray.js","../../src/structs/coercions.ts","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../node_modules/rpc-websockets/node_modules/eventemitter3/index.js","../node_modules/base-x/src/index.js","../node_modules/rpc-websockets/dist/lib/client/websocket.browser.js","../node_modules/rpc-websockets/dist/lib/client.js","../node_modules/circular-json/build/circular-json.node.js","../node_modules/jayson/lib/generateRequest.js"],"names":["basex","require","module","exports","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","inRange","a","min","max","ToDictionary","o","undefined","TypeError","Stream","tokens","this","slice","call","prototype","endOfStream","read","shift","prepend","token","Array","isArray","unshift","pop","finished","decoderError","fatal","opt_code_point","DEFAULT_ENCODING","TextDecoder","encoding","options","String","toLowerCase","Error","_streaming","_BOMseen","_decoder","_fatal","Boolean","_ignoreBOM","value","TextEncoder","_encoder","_options","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","handler","stream","bite","code_point","UTF8Encoder","count","offset","bytes","temp","decode","input","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","result","input_stream","code_points","indexOf","s","cp","fromCharCode","codePointsToString","encode","opt_string","string","n","u","c","charCodeAt","d","b","stringToCodePoints","_interopRequireDefault","Client","_classCallCheck2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_websocket","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","e","_isNativeReflectConstruct","Super","NewTarget","constructor","_CommonClient","_super","address","_ref","_ref$autoconnect","autoconnect","_ref$reconnect","reconnect","_ref$reconnect_interv","reconnect_interval","_ref$max_reconnects","max_reconnects","generate_request_id","uuid","v4","generateRequest","ClientBrowser","callServer","reviver","replacer","generator","version","notificationIdNull","request","method","params","id","callback","message","self","isBatch","hasCallback","err","JSON","stringify","response","_parseResponse","responseText","parse","isError","res","error","toFailures","run","StructError","failure","failures","rest","path","msg","cached","isObject","x","print","shiftIterator","done","toFailure","context","struct","branch","type","refinement","Symbol","r","coerce","mask","ctx","valid","ts","v","k","t","Struct","props","coercer","entries","validator","refiner","assert","create","is","validate","tuples","tuple","f","define","name","schema","any","array","Element","boolean","instance","Class","literal","constant","description","never","nullable","number","isNaN","optional","record","Key","Value","Elements","Never","Math","union","Structs","arr","arrayWithHoles","iterableToArray","unsupportedIterableToArray","nonIterableRest","unknown","condition","_objectWithoutProperties","excluded","sourceKeys","sourceSymbolKeys","propertyIsEnumerable","has","hasOwnProperty","prefix","Events","EE","fn","once","addListener","emitter","event","listener","evt","_events","_eventsCount","clearEvent","EventEmitter","__proto__","eventNames","events","names","concat","listeners","handlers","l","ee","listenerCount","emit","a1","a2","a3","a4","a5","args","len","removeListener","j","on","removeAllListeners","off","prefixed","_Buffer","Buffer","ALPHABET","BASE_MAP","charAt","xc","BASE","LEADER","FACTOR","log","iFACTOR","decodeUnsafe","alloc","psz","zeroes","size","b256","carry","it3","it4","vch","allocUnsafe","fill","from","isBuffer","pbegin","pend","b58","it1","it2","str","repeat","WebSocketBrowserImpl","_createClass2","_EventEmitter","protocols","_this","socket","window","WebSocket","onopen","onmessage","data","onerror","onclose","code","reason","optionsOrCallback","cb","send","close","addEventListener","_regenerator","_asyncToGenerator2","_typeof2","_eventemitter","_circularJson","__rest","p","CommonClient","webSocketFactory","_a","_a$autoconnect","_a$reconnect","_a$reconnect_interval","_a$max_reconnects","rest_options","queue","rpc_id","ready","current_reconnects","_connect","assign","timeout","ws_opts","_this2","Promise","resolve","reject","jsonrpc","promise","setTimeout","_login","mark","_callee","resp","wrap","_context","prev","next","sent","abrupt","stop","_x","_listMethods","_callee2","_context2","_this3","_subscribe","_callee3","_context3","_x2","_unsubscribe","_callee4","_context4","_x3","_this4","notification","then","clearTimeout","_ref2","specialChar","safeSpecialChar","escapedSafeSpecialChar","specialCharRG","RegExp","safeSpecialCharRG","safeStartWithSpecialCharRG","$String","regenerate","root","current","retrieve","regenerateArray","replace","retrieveFromPath","split","regenerateObject","CircularJSON","space","doNotResolve","parser","doNotIgnore","inspect","all","seen","mapp","last","lvl","splice","join","generateReplacer","text","isString","generateReviver"],"mappings":"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","file":"static/js/2.bf1ada0b.chunk.js","sourcesContent":["var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","'use strict';\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\nexport {TextEncoder, TextDecoder};\n","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _websocket = _interopRequireDefault(require(\"./lib/client/websocket.browser\"));\n\nvar _client = _interopRequireDefault(require(\"./lib/client\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Client = /*#__PURE__*/function (_CommonClient) {\n  (0, _inherits2[\"default\"])(Client, _CommonClient);\n\n  var _super = _createSuper(Client);\n\n  function Client() {\n    var address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ws://localhost:8080\";\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$autoconnect = _ref.autoconnect,\n        autoconnect = _ref$autoconnect === void 0 ? true : _ref$autoconnect,\n        _ref$reconnect = _ref.reconnect,\n        reconnect = _ref$reconnect === void 0 ? true : _ref$reconnect,\n        _ref$reconnect_interv = _ref.reconnect_interval,\n        reconnect_interval = _ref$reconnect_interv === void 0 ? 1000 : _ref$reconnect_interv,\n        _ref$max_reconnects = _ref.max_reconnects,\n        max_reconnects = _ref$max_reconnects === void 0 ? 5 : _ref$max_reconnects;\n\n    var generate_request_id = arguments.length > 2 ? arguments[2] : undefined;\n    (0, _classCallCheck2[\"default\"])(this, Client);\n    return _super.call(this, _websocket[\"default\"], address, {\n      autoconnect: autoconnect,\n      reconnect: reconnect,\n      reconnect_interval: reconnect_interval,\n      max_reconnects: max_reconnects\n    }, generate_request_id);\n  }\n\n  return Client;\n}(_client[\"default\"]);\n\nexports.Client = Client;","'use strict';\n\nconst uuid = require('uuid').v4;\nconst generateRequest = require('../../generateRequest');\n\n/**\n * Constructor for a Jayson Browser Client that does not depend any node.js core libraries\n * @class ClientBrowser\n * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback\n * @param {Object} [options]\n * @param {Function} [options.reviver] Reviver function for JSON\n * @param {Function} [options.replacer] Replacer function for JSON\n * @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n * @param {Function} [options.generator] Function to use for generating request IDs\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n * @return {ClientBrowser}\n */\nconst ClientBrowser = function(callServer, options) {\n  if(!(this instanceof ClientBrowser)) {\n    return new ClientBrowser(callServer, options);\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  this.options = {\n    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,\n    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,\n    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },\n    version: typeof options.version !== 'undefined' ? options.version : 2,\n    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,\n  };\n\n  this.callServer = callServer;\n};\n\nmodule.exports = ClientBrowser;\n\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} [params] Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\nClientBrowser.prototype.request = function(method, params, id, callback) {\n  const self = this;\n  let request = null;\n\n  // is this a batch request?\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  }\n\n  // is this a raw request?\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if(isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if(typeof id === 'function') {\n      callback = id;\n      // specifically undefined because \"null\" is a notification request\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = generateRequest(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull,\n      });\n    } catch(err) {\n      if(hasCallback) {\n        return callback(err);\n      }\n      throw err;\n    }\n\n    // no callback means we should just return a raw request\n    if(!hasCallback) {\n      return request;\n    }\n\n  }\n\n  let message;\n  try {\n    message = JSON.stringify(request, this.options.replacer);\n  } catch(err) {\n    return callback(err);\n  }\n\n  this.callServer(message, function(err, response) {\n    self._parseResponse(err, response, callback);\n  });\n\n  // always return the raw request\n  return request;\n};\n\n/**\n * Parses a response from a server\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {String} responseText JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\nClientBrowser.prototype._parseResponse = function(err, responseText, callback) {\n  if(err) {\n    callback(err);\n    return;\n  }\n\n  if(!responseText) {\n    // empty response text, assume that is correct because it could be a\n    // notification which jayson does not give any body for\n    return callback();\n  }\n\n  let response;\n  try {\n    response = JSON.parse(responseText, this.options.reviver);\n  } catch(err) {\n    return callback(err);\n  }\n\n  if(callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n\n    // is batch response?\n    if(Array.isArray(response)) {\n\n      // neccesary to split strictly on validity according to spec here\n      const isError = function(res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    \n    } else {\n\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    \n    }\n  \n  }\n\n  callback(null, response);\n};\n","import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is an iterator.\n */\n\nfunction isIterable<T>(x: unknown): x is Iterable<T> {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function'\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isObject(x: unknown): x is object {\n  return typeof x === 'object' && x != null\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(x: unknown): x is { [key: string]: any } {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(x)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a single validation result to a failure.\n */\n\nexport function toFailure<T, S>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): Failure | undefined {\n  if (result === true) {\n    return\n  } else if (result === false) {\n    result = {}\n  } else if (typeof result === 'string') {\n    result = { message: result }\n  }\n\n  const { path, branch } = context\n  const { type } = struct\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  }\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    result = [result]\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value)\n\n    if (failure) {\n      yield failure\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nexport function* run<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    path?: any[]\n    branch?: any[]\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): IterableIterator<[Failure, undefined] | [undefined, T]> {\n  const { path = [], branch = [value], coerce = false, mask = false } = options\n  const ctx: Context = { path, branch }\n\n  if (coerce) {\n    value = struct.coercer(value, ctx)\n\n    if (\n      mask &&\n      struct.type !== 'type' &&\n      isObject(struct.schema) &&\n      isObject(value) &&\n      !Array.isArray(value)\n    ) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key]\n        }\n      }\n    }\n  }\n\n  let valid = true\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false\n    yield [failure, undefined]\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s as Struct, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask,\n    })\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false\n        yield [t[0], undefined]\n      } else if (coerce) {\n        v = t[1]\n\n        if (k === undefined) {\n          value = v\n        } else if (value instanceof Map) {\n          value.set(k, v)\n        } else if (value instanceof Set) {\n          value.add(v)\n        } else if (isObject(value)) {\n          value[k] = v\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value as T, ctx)) {\n      valid = false\n      yield [failure, undefined]\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value as T]\n  }\n}\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string | number> = { [K in T]: K }\n\n/**\n * Check if a type is an exact match.\n */\n\nexport type IsMatch<T, G> = T extends G ? (G extends T ? T : never) : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a union.\n */\n\nexport type IsUnion<T, U extends T = T> = (\n  T extends any ? (U extends T ? false : true) : false\n) extends false\n  ? never\n  : T\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\nexport type If<B extends Boolean, Then, Else> = B extends true ? Then : Else\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string]\n  ? [T] extends [IsMatch<T, string>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [number]\n  ? [T] extends [IsMatch<T, number>]\n    ? null\n    : [T] extends [IsUnion<T>]\n    ? EnumSchema<T>\n    : T\n  : [T] extends [boolean]\n  ? [T] extends [IsMatch<T, boolean>]\n    ? null\n    : T\n  : T extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: any\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: any\n  type!: string\n  refinement!: string | undefined\n  path!: Array<any>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Array<Failure> | undefined\n    const { message, ...rest } = failure\n    const { path } = failure\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()])\n    }\n  }\n}\n","import { toFailures, shiftIterator, StructSchema, run } from './utils'\nimport { StructError, Failure } from './error'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: (value: unknown, context: Context) => unknown\n  validator: (value: unknown, context: Context) => Iterable<Failure>\n  refiner: (value: T, context: Context) => Iterable<Failure>\n  entries: (\n    value: unknown,\n    context: Context\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>\n\n  constructor(props: {\n    type: string\n    schema: S\n    coercer?: Coercer\n    validator?: Validator\n    refiner?: Refiner<T>\n    entries?: Struct<T, S>['entries']\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {},\n    } = props\n\n    this.type = type\n    this.schema = schema\n    this.entries = entries\n    this.coercer = coercer\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.validator = () => []\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.refiner = () => []\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true, mask: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Check if a value passes a struct.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n    mask?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  const tuples = run(value, struct, options)\n  const tuple = shiftIterator(tuples)!\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0]\n        }\n      }\n    })\n\n    return [error, undefined]\n  } else {\n    const v = tuple[1]\n    return [undefined, v]\n  }\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<T = unknown> = (value: T, context: Context) => unknown\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T> = (value: T, context: Context) => Result\n","import { Struct, Context, Validator } from '../struct'\nimport { object, optional } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object structs.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(name: string, validator: Validator): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nexport function deprecated<T>(\n  struct: Struct<T>,\n  log: (value: unknown, ctx: Context) => void\n): Struct<T> {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true\n      } else {\n        log(value, ctx)\n        return struct.validator(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context) => Struct<T, any>\n): Struct<T, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx)\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let struct: Struct<T, any> | undefined\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn()\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      struct ??= fn()\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      struct ??= fn()\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  return object(subschema as Omit<S, K>)\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(name: string, validator: Validator): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n","import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  TupleSchema,\n  ObjectSchema,\n  ObjectType,\n  print,\n  run,\n  isObject,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<T extends number>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends string>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends number | string>(values: readonly T[]): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function intersection<A, B>(\n  Structs: TupleSchema<[A, B]>\n): Struct<A & B, null>\nexport function intersection<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A & B & C, null>\nexport function intersection<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A & B & C & D, null>\nexport function intersection<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A & B & C & D & E, null>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F, null>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G, null>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H, null>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q,\n  null\n>\nexport function intersection(Structs: Array<Struct<any, any>>): any {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx)\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx)\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, T>\nexport function literal<T extends number>(constant: T): Struct<T, T>\nexport function literal<T extends string>(constant: T): Struct<T, T>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  const t = typeof constant\n  return new Struct({\n    type: 'literal',\n    schema:\n      t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return (\n        value === constant ||\n        `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k as string, k, Key]\n          yield [k as string, v, Value]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          yield [key, value[key], schema[key]]\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k]\n          yield [k, k, Key]\n          yield [k, v, Value]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v as string, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A>(Structs: TupleSchema<[A]>): Struct<[A], null>\nexport function tuple<A, B>(Structs: TupleSchema<[A, B]>): Struct<[A, B], null>\nexport function tuple<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<[A, B, C], null>\nexport function tuple<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<[A, B, C, D], null>\nexport function tuple<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E], null>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F], null>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G], null>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H], null>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], null>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length)\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function union<A, B>(Structs: TupleSchema<[A, B]>): Struct<A | B, null>\nexport function union<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A | B | C, null>\nexport function union<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A | B | C | D, null>\nexport function union<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A | B | C | D | E, null>\nexport function union<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F, null>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G, null>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H, null>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I, null>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q,\n  null\n>\nexport function union(Structs: Struct<any>[]): any {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator(value, ctx) {\n      const failures = []\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx)\n        const [first] = tuples\n\n        if (!first[0]) {\n          return []\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure)\n            }\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value\n        )}`,\n        ...failures,\n      ]\n    },\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}","import { Struct, is, Coercer } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: Coercer<C>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  struct: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = require('safe-buffer').Buffer\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n","/**\n * WebSocket implements a browser-side WebSocket specification.\n * @module Client\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = _default;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _eventemitter = require(\"eventemitter3\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar WebSocketBrowserImpl = /*#__PURE__*/function (_EventEmitter) {\n  (0, _inherits2[\"default\"])(WebSocketBrowserImpl, _EventEmitter);\n\n  var _super = _createSuper(WebSocketBrowserImpl);\n\n  /** Instantiate a WebSocket class\n   * @constructor\n   * @param {String} address - url to a websocket server\n   * @param {(Object)} options - websocket options\n   * @param {(String|Array)} protocols - a list of protocols\n   * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n   */\n  function WebSocketBrowserImpl(address, options, protocols) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, WebSocketBrowserImpl);\n    _this = _super.call(this);\n    _this.socket = new window.WebSocket(address, protocols);\n\n    _this.socket.onopen = function () {\n      return _this.emit(\"open\");\n    };\n\n    _this.socket.onmessage = function (event) {\n      return _this.emit(\"message\", event.data);\n    };\n\n    _this.socket.onerror = function (error) {\n      return _this.emit(\"error\", error);\n    };\n\n    _this.socket.onclose = function (event) {\n      _this.emit(\"close\", event.code, event.reason);\n    };\n\n    return _this;\n  }\n  /**\n   * Sends data through a websocket connection\n   * @method\n   * @param {(String|Object)} data - data to be sent via websocket\n   * @param {Object} optionsOrCallback - ws options\n   * @param {Function} callback - a callback called once the data is sent\n   * @return {Undefined}\n   */\n\n\n  (0, _createClass2[\"default\"])(WebSocketBrowserImpl, [{\n    key: \"send\",\n    value: function send(data, optionsOrCallback, callback) {\n      var cb = callback || optionsOrCallback;\n\n      try {\n        this.socket.send(data);\n        cb();\n      } catch (error) {\n        cb(error);\n      }\n    }\n    /**\n     * Closes an underlying socket\n     * @method\n     * @param {Number} code - status code explaining why the connection is being closed\n     * @param {String} reason - a description why the connection is closing\n     * @return {Undefined}\n     * @throws {Error}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.socket.close(code, reason);\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener, options) {\n      this.socket.addEventListener(type, listener, options);\n    }\n  }]);\n  return WebSocketBrowserImpl;\n}(_eventemitter.EventEmitter);\n/**\n * factory method for common WebSocket instance\n * @method\n * @param {String} address - url to a websocket server\n * @param {(Object)} options - websocket options\n * @return {Undefined}\n */\n\n\nfunction _default(address, options) {\n  return new WebSocketBrowserImpl(address, options);\n}","/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _eventemitter = require(\"eventemitter3\");\n\nvar _circularJson = _interopRequireDefault(require(\"circular-json\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar __rest = void 0 && (void 0).__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}; // @ts-ignore\n\n\nvar CommonClient = /*#__PURE__*/function (_EventEmitter) {\n  (0, _inherits2[\"default\"])(CommonClient, _EventEmitter);\n\n  var _super = _createSuper(CommonClient);\n\n  /**\n   * Instantiate a Client class.\n   * @constructor\n   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n   * @param {String} address - url to a websocket server\n   * @param {Object} options - ws options object with reconnect parameters\n   * @param {Function} generate_request_id - custom generation request Id\n   * @return {CommonClient}\n   */\n  function CommonClient(webSocketFactory) {\n    var _this;\n\n    var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ws://localhost:8080\";\n\n    var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;\n    (0, _classCallCheck2[\"default\"])(this, CommonClient);\n\n    var _a$autoconnect = _a.autoconnect,\n        autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect,\n        _a$reconnect = _a.reconnect,\n        reconnect = _a$reconnect === void 0 ? true : _a$reconnect,\n        _a$reconnect_interval = _a.reconnect_interval,\n        reconnect_interval = _a$reconnect_interval === void 0 ? 1000 : _a$reconnect_interval,\n        _a$max_reconnects = _a.max_reconnects,\n        max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects,\n        rest_options = __rest(_a, [\"autoconnect\", \"reconnect\", \"reconnect_interval\", \"max_reconnects\"]);\n\n    _this = _super.call(this);\n    _this.webSocketFactory = webSocketFactory;\n    _this.queue = {};\n    _this.rpc_id = 0;\n    _this.address = address;\n    _this.autoconnect = autoconnect;\n    _this.ready = false;\n    _this.reconnect = reconnect;\n    _this.reconnect_interval = reconnect_interval;\n    _this.max_reconnects = max_reconnects;\n    _this.rest_options = rest_options;\n    _this.current_reconnects = 0;\n\n    _this.generate_request_id = generate_request_id || function () {\n      return ++_this.rpc_id;\n    };\n\n    if (_this.autoconnect) _this._connect(_this.address, Object.assign({\n      autoconnect: _this.autoconnect,\n      reconnect: _this.reconnect,\n      reconnect_interval: _this.reconnect_interval,\n      max_reconnects: _this.max_reconnects\n    }, _this.rest_options));\n    return _this;\n  }\n  /**\n   * Connects to a defined server if not connected already.\n   * @method\n   * @return {Undefined}\n   */\n\n\n  (0, _createClass2[\"default\"])(CommonClient, [{\n    key: \"connect\",\n    value: function connect() {\n      if (this.socket) return;\n\n      this._connect(this.address, Object.assign({\n        autoconnect: this.autoconnect,\n        reconnect: this.reconnect,\n        reconnect_interval: this.reconnect_interval,\n        max_reconnects: this.max_reconnects\n      }, this.rest_options));\n    }\n    /**\n     * Calls a registered RPC method on server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object|Array} params - optional method parameters\n     * @param {Number} timeout - RPC reply timeout value\n     * @param {Object} ws_opts - options passed to ws\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(method, params, timeout, ws_opts) {\n      var _this2 = this;\n\n      if (!ws_opts && \"object\" === (0, _typeof2[\"default\"])(timeout)) {\n        ws_opts = timeout;\n        timeout = null;\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (!_this2.ready) return reject(new Error(\"socket not ready\"));\n\n        var rpc_id = _this2.generate_request_id(method, params);\n\n        var message = {\n          jsonrpc: \"2.0\",\n          method: method,\n          params: params || null,\n          id: rpc_id\n        };\n\n        _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {\n          if (error) return reject(error);\n          _this2.queue[rpc_id] = {\n            promise: [resolve, reject]\n          };\n\n          if (timeout) {\n            _this2.queue[rpc_id].timeout = setTimeout(function () {\n              delete _this2.queue[rpc_id];\n              reject(new Error(\"reply timeout\"));\n            }, timeout);\n          }\n        });\n      });\n    }\n    /**\n     * Logins with the other side of the connection.\n     * @method\n     * @param {Object} params - Login credentials object\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(params) {\n        var resp;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.call(\"rpc.login\", params);\n\n              case 2:\n                resp = _context.sent;\n\n                if (resp) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"authentication failed\");\n\n              case 5:\n                return _context.abrupt(\"return\", resp);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function login(_x) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n    /**\n     * Fetches a list of client's methods registered on server.\n     * @method\n     * @return {Array}\n     */\n\n  }, {\n    key: \"listMethods\",\n    value: function () {\n      var _listMethods = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.call(\"__listMethods\");\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function listMethods() {\n        return _listMethods.apply(this, arguments);\n      }\n\n      return listMethods;\n    }()\n    /**\n     * Sends a JSON-RPC 2.0 notification to server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object} params - optional method parameters\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"notify\",\n    value: function notify(method, params) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!_this3.ready) return reject(new Error(\"socket not ready\"));\n        var message = {\n          jsonrpc: \"2.0\",\n          method: method,\n          params: params || null\n        };\n\n        _this3.socket.send(JSON.stringify(message), function (error) {\n          if (error) return reject(error);\n          resolve();\n        });\n      });\n    }\n    /**\n     * Subscribes for a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(event) {\n        var result;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (typeof event === \"string\") event = [event];\n                _context3.next = 3;\n                return this.call(\"rpc.on\", event);\n\n              case 3:\n                result = _context3.sent;\n\n                if (!(typeof event === \"string\" && result[event] !== \"ok\")) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n\n              case 6:\n                return _context3.abrupt(\"return\", result);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function subscribe(_x2) {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n    /**\n     * Unsubscribes from a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(event) {\n        var result;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (typeof event === \"string\") event = [event];\n                _context4.next = 3;\n                return this.call(\"rpc.off\", event);\n\n              case 3:\n                result = _context4.sent;\n\n                if (!(typeof event === \"string\" && result[event] !== \"ok\")) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Failed unsubscribing from an event with: \" + result);\n\n              case 6:\n                return _context4.abrupt(\"return\", result);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function unsubscribe(_x3) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\n     * Closes a WebSocket connection gracefully.\n     * @method\n     * @param {Number} code - socket close code\n     * @param {String} data - optional data to be sent before closing\n     * @return {Undefined}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      this.socket.close(code || 1000, data);\n    }\n    /**\n     * Connection/Message handler.\n     * @method\n     * @private\n     * @param {String} address - WebSocket API address\n     * @param {Object} options - ws options object\n     * @return {Undefined}\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(address, options) {\n      var _this4 = this;\n\n      this.socket = this.webSocketFactory(address, options);\n      this.socket.addEventListener(\"open\", function () {\n        _this4.ready = true;\n\n        _this4.emit(\"open\");\n\n        _this4.current_reconnects = 0;\n      });\n      this.socket.addEventListener(\"message\", function (_ref) {\n        var message = _ref.data;\n        if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n\n        try {\n          message = _circularJson[\"default\"].parse(message);\n        } catch (error) {\n          return;\n        } // check if any listeners are attached and forward event\n\n\n        if (message.notification && _this4.listeners(message.notification).length) {\n          if (!Object.keys(message.params).length) return _this4.emit(message.notification);\n          var args = [message.notification];\n          if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better\n            for (var i = 0; i < message.params.length; i++) {\n              args.push(message.params[i]);\n            } // run as microtask so that pending queue messages are resolved first\n          // eslint-disable-next-line prefer-spread\n\n          return Promise.resolve().then(function () {\n            _this4.emit.apply(_this4, args);\n          });\n        }\n\n        if (!_this4.queue[message.id]) {\n          // general JSON RPC 2.0 events\n          if (message.method && message.params) {\n            // run as microtask so that pending queue messages are resolved first\n            return Promise.resolve().then(function () {\n              _this4.emit(message.method, message.params);\n            });\n          }\n\n          return;\n        } // reject early since server's response is invalid\n\n\n        if (\"error\" in message === \"result\" in message) _this4.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" + \" or \\\"error\\\", but not both.\"));\n        if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);\n        if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);\n        delete _this4.queue[message.id];\n      });\n      this.socket.addEventListener(\"error\", function (error) {\n        return _this4.emit(\"error\", error);\n      });\n      this.socket.addEventListener(\"close\", function (_ref2) {\n        var code = _ref2.code,\n            reason = _ref2.reason;\n        if (_this4.ready) // Delay close event until internal state is updated\n          setTimeout(function () {\n            return _this4.emit(\"close\", code, reason);\n          }, 0);\n        _this4.ready = false;\n        _this4.socket = undefined;\n        if (code === 1000) return;\n        _this4.current_reconnects++;\n        if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) setTimeout(function () {\n          return _this4._connect(address, options);\n        }, _this4.reconnect_interval);\n      });\n    }\n  }]);\n  return CommonClient;\n}(_eventemitter.EventEmitter);\n\nexports[\"default\"] = CommonClient;","/*!\nCopyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\nvar\n  // should be a not so common char\n  // possibly one JSON does not encode\n  // possibly one encodeURIComponent does not encode\n  // right now this char is '~' but this might change in the future\n  specialChar = '~',\n  safeSpecialChar = '\\\\x' + (\n    '0' + specialChar.charCodeAt(0).toString(16)\n  ).slice(-2),\n  escapedSafeSpecialChar = '\\\\' + safeSpecialChar,\n  specialCharRG = new RegExp(safeSpecialChar, 'g'),\n  safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),\n\n  safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\\\\\]))' + escapedSafeSpecialChar),\n\n  indexOf = [].indexOf || function(v){\n    for(var i=this.length;i--&&this[i]!==v;);\n    return i;\n  },\n  $String = String  // there's no way to drop warnings in JSHint\n                    // about new String ... well, I need that here!\n                    // faked, and happy linter!\n;\n\nfunction generateReplacer(value, replacer, resolve) {\n  var\n    doNotIgnore = false,\n    inspect = !!replacer,\n    path = [],\n    all  = [value],\n    seen = [value],\n    mapp = [resolve ? specialChar : '[Circular]'],\n    last = value,\n    lvl  = 1,\n    i, fn\n  ;\n  if (inspect) {\n    fn = typeof replacer === 'object' ?\n      function (key, value) {\n        return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;\n      } :\n      replacer;\n  }\n  return function(key, value) {\n    // the replacer has rights to decide\n    // if a new object should be returned\n    // or if there's some key to drop\n    // let's call it here rather than \"too late\"\n    if (inspect) value = fn.call(this, key, value);\n\n    // first pass should be ignored, since it's just the initial object\n    if (doNotIgnore) {\n      if (last !== this) {\n        i = lvl - indexOf.call(all, this) - 1;\n        lvl -= i;\n        all.splice(lvl, all.length);\n        path.splice(lvl - 1, path.length);\n        last = this;\n      }\n      // console.log(lvl, key, path);\n      if (typeof value === 'object' && value) {\n    \t// if object isn't referring to parent object, add to the\n        // object path stack. Otherwise it is already there.\n        if (indexOf.call(all, value) < 0) {\n          all.push(last = value);\n        }\n        lvl = all.length;\n        i = indexOf.call(seen, value);\n        if (i < 0) {\n          i = seen.push(value) - 1;\n          if (resolve) {\n            // key cannot contain specialChar but could be not a string\n            path.push(('' + key).replace(specialCharRG, safeSpecialChar));\n            mapp[i] = specialChar + path.join(specialChar);\n          } else {\n            mapp[i] = mapp[0];\n          }\n        } else {\n          value = mapp[i];\n        }\n      } else {\n        if (typeof value === 'string' && resolve) {\n          // ensure no special char involved on deserialization\n          // in this case only first char is important\n          // no need to replace all value (better performance)\n          value = value .replace(safeSpecialChar, escapedSafeSpecialChar)\n                        .replace(specialChar, safeSpecialChar);\n        }\n      }\n    } else {\n      doNotIgnore = true;\n    }\n    return value;\n  };\n}\n\nfunction retrieveFromPath(current, keys) {\n  for(var i = 0, length = keys.length; i < length; current = current[\n    // keys should be normalized back here\n    keys[i++].replace(safeSpecialCharRG, specialChar)\n  ]);\n  return current;\n}\n\nfunction generateReviver(reviver) {\n  return function(key, value) {\n    var isString = typeof value === 'string';\n    if (isString && value.charAt(0) === specialChar) {\n      return new $String(value.slice(1));\n    }\n    if (key === '') value = regenerate(value, value, {});\n    // again, only one needed, do not use the RegExp for this replacement\n    // only keys need the RegExp\n    if (isString) value = value .replace(safeStartWithSpecialCharRG, '$1' + specialChar)\n                                .replace(escapedSafeSpecialChar, safeSpecialChar);\n    return reviver ? reviver.call(this, key, value) : value;\n  };\n}\n\nfunction regenerateArray(root, current, retrieve) {\n  for (var i = 0, length = current.length; i < length; i++) {\n    current[i] = regenerate(root, current[i], retrieve);\n  }\n  return current;\n}\n\nfunction regenerateObject(root, current, retrieve) {\n  for (var key in current) {\n    if (current.hasOwnProperty(key)) {\n      current[key] = regenerate(root, current[key], retrieve);\n    }\n  }\n  return current;\n}\n\nfunction regenerate(root, current, retrieve) {\n  return current instanceof Array ?\n    // fast Array reconstruction\n    regenerateArray(root, current, retrieve) :\n    (\n      current instanceof $String ?\n        (\n          // root is an empty string\n          current.length ?\n            (\n              retrieve.hasOwnProperty(current) ?\n                retrieve[current] :\n                retrieve[current] = retrieveFromPath(\n                  root, current.split(specialChar)\n                )\n            ) :\n            root\n        ) :\n        (\n          current instanceof Object ?\n            // dedicated Object parser\n            regenerateObject(root, current, retrieve) :\n            // value as it is\n            current\n        )\n    )\n  ;\n}\n\nvar CircularJSON = {\n  stringify: function stringify(value, replacer, space, doNotResolve) {\n    return CircularJSON.parser.stringify(\n      value,\n      generateReplacer(value, replacer, !doNotResolve),\n      space\n    );\n  },\n  parse: function parse(text, reviver) {\n    return CircularJSON.parser.parse(\n      text,\n      generateReviver(reviver)\n    );\n  },\n  // A parser should be an API 1:1 compatible with JSON\n  // it should expose stringify and parse methods.\n  // The default parser is the native JSON.\n  parser: JSON\n};\n\nmodule.exports = CircularJSON;\n","'use strict';\n\nconst uuid = require('uuid').v4;\n\n/**\n *  Generates a JSON-RPC 1.0 or 2.0 request\n *  @param {String} method Name of method to call\n *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value\n *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation\n *  @param {Object} [options]\n *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID\n *  @throws {TypeError} If any of the parameters are invalid\n *  @return {Object} A JSON-RPC 1.0 or 2.0 request\n *  @memberOf Utils\n */\nconst generateRequest = function(method, params, id, options) {\n  if(typeof method !== 'string') {\n    throw new TypeError(method + ' must be a string');\n  }\n\n  options = options || {};\n\n  // check valid version provided\n  const version = typeof options.version === 'number' ? options.version : 2;\n  if (version !== 1 && version !== 2) {\n    throw new TypeError(version + ' must be 1 or 2');\n  }\n\n  const request = {\n    method: method\n  };\n\n  if(version === 2) {\n    request.jsonrpc = '2.0';\n  }\n\n  if(params) {\n    // params given, but invalid?\n    if(typeof params !== 'object' && !Array.isArray(params)) {\n      throw new TypeError(params + ' must be an object, array or omitted');\n    }\n    request.params = params;\n  }\n\n  // if id was left out, generate one (null means explicit notification)\n  if(typeof(id) === 'undefined') {\n    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };\n    request.id = generator(request, options);\n  } else if (version === 2 && id === null) {\n    // we have a version 2 notification\n    if (options.notificationIdNull) {\n      request.id = null; // id will not be set at all unless option provided\n    }\n  } else {\n    request.id = id;\n  }\n\n  return request;\n};\n\nmodule.exports = generateRequest;\n"],"sourceRoot":""}