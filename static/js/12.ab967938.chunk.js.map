{"version":3,"sources":["../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/errors-browser.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/_stream_duplex.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/end-of-stream.js","../../src/randomId.ts","../../src/utils.ts","../../src/url.ts","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/readable-browser.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/_stream_readable.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/stream-browser.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/destroy.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/state.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/_stream_writable.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/_stream_transform.js","../../src/constants.ts","../../src/loglevel.ts","../../src/Modal.ts","../../src/MemoryStore.ts","../../src/OpenLoginStore.ts","../../src/Provider.ts","../../src/OpenLogin.ts","../../src/basePostMessageStream.ts","../../src/safeEventEmitter.ts","../../src/serializableError.ts","../../src/jrpc.ts","../../src/jrpcEngine.ts","../../src/substream.ts","../../src/mux.ts","../../src/postMessageStream.ts","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/buffer_list.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/async_iterator.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/from-browser.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/_stream_passthrough.js","../node_modules/@web3auth/openlogin-adapter/node_modules/readable-stream/lib/internal/streams/pipeline.js","../../src/config.ts","../../src/openloginAdapter.ts"],"names":["codes","createErrorType","code","message","Base","Error","NodeError","_Base","subClass","superClass","arg1","arg2","arg3","call","this","getMessage","prototype","Object","create","constructor","__proto__","name","oneOf","expected","thing","Array","isArray","len","length","map","i","String","concat","slice","join","value","TypeError","actual","determiner","search","pos","msg","substr","replace","str","this_len","undefined","substring","endsWith","type","start","indexOf","includes","arg","module","exports","objectKeys","keys","obj","key","push","Duplex","Readable","require","Writable","v","method","options","allowHalfOpen","readable","writable","once","onend","_writableState","ended","process","nextTick","onEndNT","self","end","defineProperty","enumerable","get","highWaterMark","getBuffer","_readableState","destroyed","set","ERR_STREAM_PREMATURE_CLOSE","noop","eos","stream","opts","callback","called","_len","arguments","args","_key","apply","onlegacyfinish","onfinish","writableEnded","finished","readableEnded","endEmitted","onerror","err","onclose","onrequest","req","on","setHeader","abort","isRequest","error","removeListener","randomId","randombytes","base64url","URL","base64urlLib","safeatob","keccak","keccakLib","jsonToBase64","json","JSON","Stream","Transform","PassThrough","pipeline","ReadableState","EventEmitter","EElistenerCount","emitter","listeners","Buffer","OurUint8Array","global","Uint8Array","debug","debugUtil","debuglog","StringDecoder","createReadableStreamAsyncIterator","from","BufferList","destroyImpl","getHighWaterMark","_require$codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PUSH_AFTER_EOF","ERR_METHOD_NOT_IMPLEMENTED","ERR_STREAM_UNSHIFT_AFTER_END_EVENT","errorOrDestroy","kProxyEvents","isDuplex","objectMode","readableObjectMode","buffer","pipes","pipesCount","flowing","reading","sync","needReadable","emittedReadable","readableListening","resumeScheduled","paused","emitClose","autoDestroy","defaultEncoding","awaitDrain","readingMore","decoder","encoding","read","_read","destroy","_destroy","readableAddChunk","chunk","addToFront","skipChunkCheck","er","state","emitReadable","emitReadable_","onEofChunk","isBuffer","chunkInvalid","getPrototypeOf","_uint8ArrayToBuffer","addChunk","write","maybeReadMore","emit","unshift","_undestroy","undestroy","cb","isPaused","setEncoding","enc","p","head","content","data","next","clear","MAX_HWM","howMuchToRead","n","computeNewHighWaterMark","flow","maybeReadMore_","updateReadableListening","listenerCount","resume","nReadingNextTick","resume_","fromList","ret","shift","first","consume","endReadable","endReadableNT","wState","xs","x","l","parseInt","nOrig","doRead","pipe","dest","pipeOpts","src","endFn","stdout","stderr","unpipe","onunpipe","unpipeInfo","hasUnpiped","ondrain","ondata","cleanedUp","needDrain","pipeOnDrain","pause","event","fn","prependListener","_events","dests","index","splice","ev","res","addListener","removeAllListeners","wrap","_this","bind","Symbol","asyncIterator","_fromList","iterable","emitErrorAndCloseNT","emitErrorNT","emitCloseNT","readableDestroyed","writableDestroyed","errorEmitted","ending","finalCalled","prefinished","rState","ERR_INVALID_OPT_VALUE","duplexKey","hwm","highWaterMarkFrom","isFinite","Math","floor","CorkedRequest","entry","finish","corkReq","pendingcb","corkedRequestsFree","onCorkedFinish","WritableState","internalUtil","deprecate","realHasInstance","ERR_MULTIPLE_CALLBACK","ERR_STREAM_CANNOT_PIPE","ERR_STREAM_DESTROYED","ERR_STREAM_NULL_VALUES","ERR_STREAM_WRITE_AFTER_END","ERR_UNKNOWN_ENCODING","nop","writableObjectMode","noDecode","decodeStrings","writing","corked","bufferProcessing","onwrite","writecb","writelen","onwriteStateUpdate","finishMaybe","onwriteError","needFinish","bufferedRequest","clearBuffer","afterWrite","lastBufferedRequest","bufferedRequestCount","_write","writev","_writev","final","_final","doWrite","onwriteDrain","holder","count","allBuffers","isBuf","callFinal","need","prefinish","current","out","_","hasInstance","Function","object","writeAfterEnd","validChunk","newChunk","decodeChunk","last","writeOrBuffer","cork","uncork","setDefaultEncoding","toLowerCase","endWritable","ERR_TRANSFORM_ALREADY_TRANSFORMING","ERR_TRANSFORM_WITH_LENGTH_0","afterTransform","ts","_transformState","transforming","writechunk","rs","needTransform","writeencoding","transform","_transform","flush","_flush","done","err2","modalDOMElementID","storeKey","UX_MODE","POPUP","REDIRECT","OPENLOGIN_METHOD","ALLOWED_INTERACTIONS","OPENLOGIN_NETWORK","MAINNET","TESTNET","CYAN","DEVELOPMENT","loglevel","resolve","document","htmlToElement","html","template","window","trimmedHtml","getHashQueryParams","replaceUrl","result","url","queryResult","queryParams","log","hash","hashUrl","hashResult","hashParams","cleanUrl","awaitReq","id","windowRef","reject","closedByHandler","closedMonitor","setInterval","clearInterval","handler","pid","constructURL","params","query","h","baseURL","storageAvailable","storageExists","storageLength","storage","localStorageAvailable","getPopupFeatures","dualScreenLeft","dualScreenTop","width","height","left","top","w","handleStream","handle","handlerWrapper","Modal","modalUrl","init","setupStream","setupMultiplex","target","targetWindow","targetOrigin","origin","initIFrame","documentReady","documentIFrameElem","_showModal","style","_hideModal","_prompt","modalHandler","clientId","whiteLabel","loginConfig","cleanup","MemoryStore","getItem","setItem","OpenLoginStore","toJSON","resetStore","currStore","getStore","store","getInstance","Provider","iframeUrl","JRPCConnection","createStreamMiddleware","pump","rpcEngine","createIdRemapMiddleware","_rpcRequest","payload","SafeEventEmitter","openloginIframeHtml","preloadIframe","deleteProperty","no3PC","_iframeUrl","_startUrl","_popupUrl","redirectUrl","uxMode","replaceUrlOnRedirect","originData","privKey","initState","network","startUrl","popupUrl","support3PC","Promise","iframeElem","updateOriginData","filteredOriginData","getWhitelist","getWhiteLabel","_fastLogin","defaultParams","loginParams","fastLogin","allowedInteractions","login","_selectedLogin","loginProvider","logout","logoutParams","request","session","userData","timestamp","Date","sign","sig","getPublic","setTimeout","b64Params","_pid","_method","u","_jrpcRequest","getRpcPromiseCallback","_check3PCSupport","_originData","_setPIDData","_getData","_syncState","newState","_modal","merge","selectedLoginResponse","_cleanup","encrypt","decrypt","getUserInfo","storeData","userInfo","email","profileImage","aggregateVerifier","verifier","verifierId","typeOfLogin","dappShare","getEncodedLoginUrl","dataObject","_clientId","_origin","ACK","BasePostMessageStream","_break","_handShake","_onData","_postMessage","originConstraint","onMessage","Reflect","arr","copy","doError","events","safeApply","arrayClone","SerializableError","Number","toString","stringify","stack","serializeError","unwrapResult","response","idMap","processNotification","context","processResponse","middleware","originalId","newId","JRPCEngine","asMiddleware","handlerCallback","_handleBatch","reqs","responses","_promiseHandle","_handle","jsonrpc","callerReq","_processRequest","_runAllMiddleware","returnHandlers","isComplete","_runMiddleware","returnHandler","_runReturnHandlers","_checkForCompletion","Substream","IGNORE_SUBSTREAM","ObjectMultiplex","createStream","substream","parent","anyStreamEnd","_error","ignoreStream","mux","PostMessageStream","dataObj","dataObjData","dataObjDataParam","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_defineProperty","configurable","_defineProperties","props","descriptor","inspect","custom","instance","Constructor","_classCallCheck","tail","protoProps","staticProps","s","alloc","offset","allocUnsafe","hasStrings","_getString","_getBuffer","c","nb","buf","source","forEach","getOwnPropertyDescriptors","defineProperties","_objectSpread","depth","customInspect","_Object$setPrototypeO","kLastResolve","kLastReject","kError","kEnded","kLastPromise","kHandlePromise","kStream","createIterResult","readAndResolve","iter","onReadable","AsyncIteratorPrototype","ReadableStreamAsyncIteratorPrototype","setPrototypeOf","promise","lastPromise","then","wrapForNext","_this2","_Object$create","iterator","ERR_MISSING_ARGS","destroyer","closed","to","popCallback","streams","pop","destroys","reduce","getOpenloginDefaultOptions","adapterSettings","chainConfig","chainNamespace","getChainConfig","loginSettings","relogin","WALLET_ADAPTERS","OPENLOGIN","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","defaultOptions","defaultChainIdConfig","WalletInitializationError","chainConfigProxy","provider","privKeyProvider","isRedirectResult","redirectResult","openloginOptions","ADAPTER_EVENTS","connect","adapter","WalletLoginError","disconnect","openloginInstance","setAdapterSettings","setChainConfig","customChainConfig","connectWithProvider","SolanaPrivateKeyProvider","config","EthereumPrivateKeyProvider","extraLoginOptions","login_hint","finalPrivKey","getED25519Key","reconnected"],"mappings":"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","file":"static/js/12.ab967938.chunk.js","sourcesContent":["'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n'use strict';\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = require('./_stream_readable');\n\nvar Writable = require('./_stream_writable');\n\nrequire('inherits')(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;","import randombytes from 'randombytes';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport base64urlLib from 'base64url';\nimport keccakLib from 'keccak';\n\n// TODO: should be crypto safe\nconst randomId = () => randombytes(32).toString(\"hex\");\n\nclass URLWithHashParams extends URL {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"hashParams\", new URLSearchParams());\n  }\n\n  toString() {\n    this.hash = this.hashParams.toString();\n    return super.toString.call(this);\n  }\n\n}\n\nconst base64url = base64urlLib;\nfunction safebtoa(str) {\n  return base64url.encode(str);\n}\nfunction safeatob(str) {\n  // Going backwards: from bytestream, to percent-encoding, to original string.\n  return base64url.decode(str);\n}\nconst keccak = keccakLib;\nfunction base64toJSON(b64str) {\n  return JSON.parse(base64url.decode(b64str));\n}\nfunction jsonToBase64(json) {\n  return base64url.encode(JSON.stringify(json));\n}\nfunction keccak256(str) {\n  let input = str;\n\n  if (typeof str === \"string\" && str.slice(0, 2) === \"0x\" && str.length === 66) {\n    input = Buffer.from(str.slice(2), \"hex\");\n  }\n\n  const data = \"0x\".concat(keccak(\"keccak256\").update(input).digest(\"hex\").padStart(64, \"0\"));\n  return data;\n}\n\nexport { URLWithHashParams, base64toJSON, base64url, jsonToBase64, keccak, keccak256, randomId, safeatob, safebtoa };\n//# sourceMappingURL=openloginUtils.esm.js.map\n",null,null,"exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nexports.finished = require('./lib/internal/streams/end-of-stream.js');\nexports.pipeline = require('./lib/internal/streams/pipeline.js');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict';\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = require('util');\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = require('./internal/streams/buffer_list');\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\nrequire('inherits')(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}","module.exports = require('events').EventEmitter;\n","'use strict'; // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nvar _require = require('./internal/streams/state'),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = require('../errors').codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\nrequire('inherits')(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n'use strict';\n\nmodule.exports = Transform;\n\nvar _require$codes = require('../errors').codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = require('./_stream_duplex');\n\nrequire('inherits')(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","import loglevel from 'loglevel';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { getPublic, sign, encrypt, decrypt } from '@toruslabs/eccrypto';\nimport { get } from '@toruslabs/http-helpers';\nimport { setupMultiplex, PostMessageStream, SafeEventEmitter, createStreamMiddleware, JRPCEngine, createIdRemapMiddleware, getRpcPromiseCallback } from '@toruslabs/openlogin-jrpc';\nimport { base64url, keccak, safeatob, randomId, jsonToBase64 } from '@toruslabs/openlogin-utils';\nimport merge from 'lodash.merge';\nimport pump from 'pump';\n\nconst modalDOMElementID = \"openlogin-modal\";\nconst storeKey = \"openlogin_store\";\nconst UX_MODE = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\"\n};\nconst OPENLOGIN_METHOD = {\n  LOGIN: \"openlogin_login\",\n  LOGOUT: \"openlogin_logout\",\n  CHECK_3PC_SUPPORT: \"openlogin_check_3PC_support\",\n  SET_PID_DATA: \"openlogin_set_pid_data\",\n  GET_DATA: \"openlogin_get_data\"\n};\nconst ALLOWED_INTERACTIONS = {\n  POPUP: \"popup\",\n  REDIRECT: \"redirect\",\n  JRPC: \"jrpc\"\n};\nconst OPENLOGIN_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  DEVELOPMENT: \"development\"\n};\nconst LOGIN_PROVIDER = {\n  GOOGLE: \"google\",\n  FACEBOOK: \"facebook\",\n  REDDIT: \"reddit\",\n  DISCORD: \"discord\",\n  TWITCH: \"twitch\",\n  APPLE: \"apple\",\n  LINE: \"line\",\n  GITHUB: \"github\",\n  KAKAO: \"kakao\",\n  LINKEDIN: \"linkedin\",\n  TWITTER: \"twitter\",\n  WEIBO: \"weibo\",\n  WECHAT: \"wechat\",\n  EMAIL_PASSWORDLESS: \"email_passwordless\",\n  WEBAUTHN: \"webauthn\",\n  JWT: \"jwt\"\n};\nconst MFA_LEVELS = {\n  DEFAULT: \"default\",\n  OPTIONAL: \"optional\",\n  MANDATORY: \"mandatory\"\n};\n\nloglevel.setLevel(\"error\");\nvar log = loglevel.getLogger(\"openlogin\");\n\nasync function documentReady() {\n  return new Promise(resolve => {\n    if (document.readyState !== \"loading\") {\n      resolve();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => {\n        resolve();\n      });\n    }\n  });\n}\nconst htmlToElement = html => {\n  const template = window.document.createElement(\"template\");\n  const trimmedHtml = html.trim(); // Never return a text node of whitespace as the result\n\n  template.innerHTML = trimmedHtml;\n  return template.content.firstChild;\n};\nasync function whitelistUrl(clientId, appKey, origin) {\n  const appKeyBuf = Buffer.from(appKey.padStart(64, \"0\"), \"hex\");\n  if (base64url.encode(getPublic(appKeyBuf)) !== clientId) throw new Error(\"appKey mismatch\");\n  const sig = await sign(appKeyBuf, Buffer.from(keccak(\"keccak256\").update(origin).digest(\"hex\"), \"hex\"));\n  return base64url.encode(sig);\n}\nfunction getHashQueryParams() {\n  let replaceUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  const result = {};\n  const url = new URL(window.location.href);\n  url.searchParams.forEach((value, key) => {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  const queryResult = url.searchParams.get(\"result\");\n\n  if (queryResult) {\n    try {\n      const queryParams = JSON.parse(safeatob(queryResult));\n      Object.keys(queryParams).forEach(key => {\n        result[key] = queryParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  const hash = url.hash.substring(1);\n  const hashUrl = new URL(\"\".concat(window.location.origin, \"/?\").concat(hash));\n  hashUrl.searchParams.forEach((value, key) => {\n    if (key !== \"result\") {\n      result[key] = value;\n    }\n  });\n  const hashResult = hashUrl.searchParams.get(\"result\");\n\n  if (hashResult) {\n    try {\n      const hashParams = JSON.parse(safeatob(hashResult));\n      Object.keys(hashParams).forEach(key => {\n        result[key] = hashParams[key];\n      });\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  if (replaceUrl) {\n    const cleanUrl = window.location.origin + window.location.pathname;\n    window.history.replaceState(null, \"\", cleanUrl);\n  }\n\n  return result;\n}\nfunction awaitReq(id, windowRef) {\n  return new Promise((resolve, reject) => {\n    if (!windowRef) reject(new Error(\"Unable to open window\"));\n    let closedByHandler = false;\n    const closedMonitor = setInterval(() => {\n      if (!closedByHandler && windowRef.closed) {\n        clearInterval(closedMonitor);\n        reject(new Error(\"user closed popup\"));\n      }\n    }, 500);\n\n    const handler = ev => {\n      const {\n        pid\n      } = ev.data;\n      if (id !== pid) return;\n      window.removeEventListener(\"message\", handler);\n      closedByHandler = true;\n      clearInterval(closedMonitor);\n      windowRef.close();\n\n      if (ev.data.data && ev.data.data.error) {\n        reject(new Error(ev.data.data.error));\n      } else {\n        resolve(ev.data.data);\n      }\n    };\n\n    window.addEventListener(\"message\", handler);\n  });\n}\nfunction constructURL(params) {\n  const {\n    baseURL,\n    query,\n    hash\n  } = params;\n  const url = new URL(baseURL);\n\n  if (query) {\n    Object.keys(query).forEach(key => {\n      url.searchParams.append(key, query[key]);\n    });\n  }\n\n  if (hash) {\n    const h = new URL(constructURL({\n      baseURL,\n      query: hash\n    })).searchParams.toString();\n    url.hash = h;\n  }\n\n  return url.toString();\n}\nfunction storageAvailable(type) {\n  let storageExists = false;\n  let storageLength = 0;\n  let storage;\n\n  try {\n    storage = window[type];\n    storageExists = true;\n    storageLength = storage.length;\n    const x = \"__storage_test__\";\n    storage.setItem(x, x);\n    storage.removeItem(x);\n    return true;\n  } catch (error) {\n    return error && ( // everything except Firefox\n    error.code === 22 || // Firefox\n    error.code === 1014 || // test name field too, because code might not be present\n    // everything except Firefox\n    error.name === \"QuotaExceededErro r\" || // Firefox\n    error.name === \"NS_ERROR_DOM_QUOTA_REACHED\") && // acknowledge QuotaExceededError only if there's something already stored\n    storageExists && storageLength !== 0;\n  }\n}\nconst sessionStorageAvailable = storageAvailable(\"sessionStorage\");\nconst localStorageAvailable = storageAvailable(\"localStorage\");\nfunction preloadIframe(url) {\n  try {\n    if (typeof document === \"undefined\") return;\n    const openloginIframeHtml = document.createElement(\"link\");\n    openloginIframeHtml.href = url;\n    openloginIframeHtml.crossOrigin = \"anonymous\";\n    openloginIframeHtml.type = \"text/html\";\n    openloginIframeHtml.rel = \"prefetch\";\n\n    if (openloginIframeHtml.relList && openloginIframeHtml.relList.supports) {\n      if (openloginIframeHtml.relList.supports(\"prefetch\")) {\n        document.head.appendChild(openloginIframeHtml);\n      }\n    }\n  } catch (error) {\n    log.error(error);\n  }\n}\nfunction getPopupFeatures() {\n  // Fixes dual-screen position                             Most browsers      Firefox\n  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;\n  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;\n  const w = 1200;\n  const h = 700;\n  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;\n  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;\n  const systemZoom = 1; // No reliable estimate\n\n  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);\n  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);\n  const features = \"titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=\".concat(h / systemZoom, \",width=\").concat(w / systemZoom, \",top=\").concat(top, \",left=\").concat(left);\n  return features;\n}\n\nconst handleStream = (handle, eventName, handler) => {\n  const handlerWrapper = chunk => {\n    handler(chunk);\n    handle.removeListener(eventName, handlerWrapper);\n  };\n\n  handle.on(eventName, handlerWrapper);\n};\nclass Modal {\n  constructor(modalUrl) {\n    _defineProperty(this, \"modalUrl\", void 0);\n\n    _defineProperty(this, \"iframeElem\", void 0);\n\n    _defineProperty(this, \"initialized\", false);\n\n    _defineProperty(this, \"modalZIndex\", 99999);\n\n    _defineProperty(this, \"mux\", void 0);\n\n    _defineProperty(this, \"verifierStream\", void 0);\n\n    this.modalUrl = modalUrl;\n  }\n\n  async init() {\n    await this.initIFrame(this.modalUrl);\n    this.setupStream();\n  }\n\n  setupStream() {\n    if (this.iframeElem === null) throw new Error(\"iframe is null\");\n    this.mux = setupMultiplex(new PostMessageStream({\n      name: \"modal_iframe_rpc\",\n      target: \"modal_rpc\",\n      targetWindow: this.iframeElem.contentWindow,\n      targetOrigin: new URL(this.modalUrl).origin\n    }));\n    this.verifierStream = this.mux.createStream(\"verifier\");\n  }\n\n  async initIFrame(src) {\n    await documentReady();\n    const documentIFrameElem = document.getElementById(modalDOMElementID);\n\n    if (documentIFrameElem) {\n      documentIFrameElem.remove();\n      log.info(\"already initialized, removing previous modal iframe\");\n    }\n\n    this.iframeElem = htmlToElement(\"<iframe\\n        id=\".concat(modalDOMElementID, \"\\n        class=\\\"torusIframe\\\"\\n        src=\\\"\").concat(src, \"\\\"\\n        style=\\\"display: none; position: fixed; top: 0; right: 0; width: 100%;\\n        height: 100%; border: none; border-radius: 0; z-index: \").concat(this.modalZIndex.toString(), \"\\\"\\n      ></iframe>\"));\n\n    this._hideModal();\n\n    document.body.appendChild(this.iframeElem);\n    return new Promise(resolve => {\n      this.iframeElem.onload = () => {\n        this.initialized = true;\n        resolve();\n      };\n    });\n  }\n\n  _showModal() {\n    const style = {};\n    style.display = \"block\";\n    style.position = \"fixed\";\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.top = \"0px\";\n    style.right = \"0px\";\n    style.left = \"0px\";\n    style.bottom = \"0px\";\n    style.border = \"0\";\n    style[\"z-index\"] = this.modalZIndex;\n    this.iframeElem.setAttribute(\"style\", Object.entries(style).map(_ref => {\n      let [k, v] = _ref;\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\";\"));\n  }\n\n  _hideModal() {\n    const style = {};\n    style.display = \"none\";\n    style.position = \"fixed\";\n    style.width = \"100%\";\n    style.height = \"100%\";\n    style.top = \"0px\";\n    style.right = \"0px\";\n    style.left = \"0px\";\n    style.bottom = \"0px\";\n    style.border = \"0\";\n    style[\"z-index\"] = this.modalZIndex;\n    this.iframeElem.setAttribute(\"style\", Object.entries(style).map(_ref2 => {\n      let [k, v] = _ref2;\n      return \"\".concat(k, \":\").concat(v);\n    }).join(\";\"));\n  }\n\n  async _prompt(clientId, whiteLabel, loginConfig, cb) {\n    this._showModal();\n\n    const modalHandler = chunk => {\n      this._hideModal();\n\n      cb(chunk);\n    };\n\n    handleStream(this.verifierStream, \"data\", modalHandler);\n    this.verifierStream.write({\n      name: \"prompt\",\n      clientId,\n      whiteLabel,\n      loginConfig\n    });\n  }\n\n  async cleanup() {\n    await documentReady();\n    const documentIFrameElem = document.getElementById(modalDOMElementID);\n\n    if (documentIFrameElem) {\n      documentIFrameElem.remove();\n      this.iframeElem = null;\n    }\n\n    this.initialized = false;\n  }\n\n}\n\nclass MemoryStore {\n  constructor() {\n    _defineProperty(this, \"store\", {});\n  }\n\n  getItem(key) {\n    return this.store[key];\n  }\n\n  setItem(key, value) {\n    this.store[key] = value;\n  }\n\n}\n\nclass OpenLoginStore {\n  // eslint-disable-next-line no-use-before-define\n  constructor(storage) {\n    _defineProperty(this, \"storage\", void 0);\n\n    this.storage = storage;\n\n    try {\n      if (!storage.getItem(storeKey)) {\n        this.resetStore();\n      }\n    } catch (error) {// Storage is not available\n    }\n  }\n\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new this(localStorageAvailable ? localStorage : new MemoryStore());\n    }\n\n    return this.instance;\n  }\n\n  toJSON() {\n    return this.storage.getItem(storeKey);\n  }\n\n  resetStore() {\n    const currStore = this.getStore();\n    this.storage.setItem(storeKey, JSON.stringify({}));\n    return currStore;\n  }\n\n  getStore() {\n    return JSON.parse(this.storage.getItem(storeKey));\n  }\n\n  get(key) {\n    const store = JSON.parse(this.storage.getItem(storeKey));\n    return store[key];\n  }\n\n  set(key, value) {\n    const store = JSON.parse(this.storage.getItem(storeKey));\n    store[key] = value;\n    this.storage.setItem(storeKey, JSON.stringify(store));\n  }\n\n}\n\n_defineProperty(OpenLoginStore, \"instance\", void 0);\n\nclass Provider extends SafeEventEmitter {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"iframeElem\", null);\n\n    _defineProperty(this, \"rpcStream\", void 0);\n\n    _defineProperty(this, \"iframeUrl\", void 0);\n\n    _defineProperty(this, \"rpcEngine\", void 0);\n\n    _defineProperty(this, \"initialized\", void 0);\n\n    _defineProperty(this, \"mux\", void 0);\n  }\n\n  init(_ref) {\n    let {\n      iframeElem,\n      iframeUrl\n    } = _ref;\n    this.iframeElem = iframeElem;\n    this.iframeUrl = iframeUrl;\n    this.setupStream();\n    this.initialized = true;\n  }\n\n  setupStream() {\n    if (this.iframeElem === null) throw new Error(\"iframe is null\");\n    this.rpcStream = new PostMessageStream({\n      name: \"embed_rpc\",\n      target: \"iframe_rpc\",\n      targetWindow: this.iframeElem.contentWindow,\n      targetOrigin: new URL(this.iframeUrl).origin\n    });\n    this.mux = setupMultiplex(this.rpcStream);\n    const JRPCConnection = createStreamMiddleware();\n    pump(JRPCConnection.stream, this.mux.createStream(\"jrpc\"), JRPCConnection.stream, error => {\n      log.error(\"JRPC connection broken\", error);\n    });\n    const rpcEngine = new JRPCEngine();\n    rpcEngine.push(createIdRemapMiddleware());\n    rpcEngine.push(JRPCConnection.middleware);\n    this.rpcEngine = rpcEngine;\n  }\n\n  cleanup() {\n    this.iframeElem = null;\n    this.initialized = false;\n  }\n\n  _rpcRequest(payload, callback) {\n    if (!payload.jsonrpc) {\n      payload.jsonrpc = \"2.0\";\n    }\n\n    if (!payload.id) {\n      payload.id = randomId();\n    }\n\n    this.rpcEngine.handle(payload, callback);\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\npreloadIframe(\"https://app.openlogin.com/sdk-modal\");\n\nclass OpenLogin {\n  constructor(options) {\n    var _options$no3PC, _options$_startUrl, _options$_popupUrl, _options$redirectUrl, _options$uxMode, _options$replaceUrlOn, _options$originData, _options$whiteLabel, _options$loginConfig;\n\n    _defineProperty(this, \"provider\", void 0);\n\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"modal\", void 0);\n\n    this.provider = new Proxy(new Provider(), {\n      deleteProperty: () => true // work around for web3\n\n    });\n\n    if (!options._iframeUrl) {\n      if (options.network === OPENLOGIN_NETWORK.MAINNET) {\n        options._iframeUrl = \"https://app.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.CYAN) {\n        options._iframeUrl = \"https://cyan.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.TESTNET) {\n        options._iframeUrl = \"https://beta.openlogin.com\";\n      } else if (options.network === OPENLOGIN_NETWORK.DEVELOPMENT) {\n        options._iframeUrl = \"http://localhost:3000\";\n      }\n    }\n\n    if (!options._iframeUrl) {\n      throw new Error(\"unspecified network and iframeUrl\");\n    }\n\n    this.modal = new Modal(\"\".concat(options._iframeUrl, \"/sdk-modal\"));\n    this.initState(_objectSpread(_objectSpread({}, options), {}, {\n      no3PC: (_options$no3PC = options.no3PC) !== null && _options$no3PC !== void 0 ? _options$no3PC : false,\n      _iframeUrl: options._iframeUrl,\n      _startUrl: (_options$_startUrl = options._startUrl) !== null && _options$_startUrl !== void 0 ? _options$_startUrl : \"\".concat(options._iframeUrl, \"/start\"),\n      _popupUrl: (_options$_popupUrl = options._popupUrl) !== null && _options$_popupUrl !== void 0 ? _options$_popupUrl : \"\".concat(options._iframeUrl, \"/popup-window\"),\n      redirectUrl: (_options$redirectUrl = options.redirectUrl) !== null && _options$redirectUrl !== void 0 ? _options$redirectUrl : \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(window.location.pathname),\n      uxMode: (_options$uxMode = options.uxMode) !== null && _options$uxMode !== void 0 ? _options$uxMode : UX_MODE.REDIRECT,\n      replaceUrlOnRedirect: (_options$replaceUrlOn = options.replaceUrlOnRedirect) !== null && _options$replaceUrlOn !== void 0 ? _options$replaceUrlOn : true,\n      originData: (_options$originData = options.originData) !== null && _options$originData !== void 0 ? _options$originData : {\n        [window.location.origin]: \"\"\n      },\n      whiteLabel: (_options$whiteLabel = options.whiteLabel) !== null && _options$whiteLabel !== void 0 ? _options$whiteLabel : {},\n      loginConfig: (_options$loginConfig = options.loginConfig) !== null && _options$loginConfig !== void 0 ? _options$loginConfig : {}\n    }));\n  }\n\n  get privKey() {\n    return this.state.privKey ? this.state.privKey.padStart(64, \"0\") : \"\";\n  }\n\n  initState(options) {\n    this.state = {\n      uxMode: options.uxMode,\n      network: options.network,\n      store: OpenLoginStore.getInstance(),\n      iframeUrl: options._iframeUrl,\n      startUrl: options._startUrl,\n      popupUrl: options._popupUrl,\n      clientId: options.clientId,\n      redirectUrl: options.redirectUrl,\n      replaceUrlOnRedirect: options.replaceUrlOnRedirect,\n      originData: options.originData,\n      loginConfig: options.loginConfig,\n      support3PC: !options.no3PC,\n      whiteLabel: options.whiteLabel\n    };\n  }\n\n  async init() {\n    if (this.state.support3PC) {\n      await Promise.all([this.modal.init(), this.updateOriginData()]);\n      this.provider.init({\n        iframeElem: this.modal.iframeElem,\n        iframeUrl: this.state.iframeUrl\n      });\n\n      this._syncState(getHashQueryParams(this.state.replaceUrlOnRedirect));\n\n      const res = await this._check3PCSupport();\n      this.state.support3PC = !!res.support3PC;\n\n      if (this.state.support3PC) {\n        this._syncState(await this._getData());\n      }\n    } else {\n      await this.updateOriginData();\n\n      this._syncState(getHashQueryParams(this.state.replaceUrlOnRedirect));\n    }\n  }\n\n  async updateOriginData() {\n    const filteredOriginData = JSON.parse(JSON.stringify(this.state.originData));\n    Object.keys(filteredOriginData).forEach(key => {\n      if (filteredOriginData[key] === \"\") delete filteredOriginData[key];\n    });\n    const [whitelist, whiteLabel] = await Promise.all([this.getWhitelist(), this.getWhiteLabel()]);\n\n    this._syncState({\n      originData: _objectSpread(_objectSpread({}, whitelist), filteredOriginData),\n      whiteLabel: _objectSpread(_objectSpread({}, whiteLabel), this.state.whiteLabel)\n    });\n  }\n\n  async getWhitelist() {\n    try {\n      const {\n        clientId\n      } = this.state;\n\n      if (!clientId) {\n        throw new Error(\"unspecified clientId\");\n      }\n\n      const url = new URL(\"https://api.developer.tor.us/whitelist\");\n      url.searchParams.append(\"project_id\", this.state.clientId);\n      const res = await get(url.href);\n      return res.signed_urls;\n    } catch (_) {\n      // fail silently\n      return {};\n    }\n  }\n\n  async getWhiteLabel() {\n    try {\n      const {\n        clientId\n      } = this.state;\n\n      if (!clientId) {\n        throw new Error(\"unspecified clientId\");\n      }\n\n      const url = new URL(\"https://api.developer.tor.us/whitelabel\");\n      url.searchParams.append(\"project_id\", this.state.clientId);\n      const res = await get(url.href);\n      return res.whiteLabel;\n    } catch (_) {\n      // fail silently\n      return {};\n    }\n  }\n\n  async _fastLogin(params) {\n    const defaultParams = {\n      redirectUrl: this.state.redirectUrl\n    };\n\n    const loginParams = _objectSpread(_objectSpread({}, defaultParams), params);\n\n    const res = await this.request({\n      params: [_objectSpread(_objectSpread({}, loginParams), {}, {\n        fastLogin: true\n      })],\n      method: OPENLOGIN_METHOD.LOGIN,\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      allowedInteractions: [ALLOWED_INTERACTIONS.POPUP, ALLOWED_INTERACTIONS.REDIRECT]\n    });\n    this.state.privKey = res.privKey;\n    return res;\n  }\n\n  async login(params) {\n    if (params !== null && params !== void 0 && params.loginProvider) {\n      return this._selectedLogin(params);\n    }\n\n    return this._modal(params);\n  }\n\n  async _selectedLogin(params) {\n    const defaultParams = {\n      redirectUrl: this.state.redirectUrl\n    };\n\n    const loginParams = _objectSpread(_objectSpread({\n      loginProvider: params.loginProvider\n    }, defaultParams), params); // fast login flow\n    // if (this.state.store.get(\"touchIDPreference\") === \"enabled\" && !loginParams.extraLoginOptions?.login_hint) {\n    //   return this._fastLogin(loginParams);\n    // }\n\n\n    const res = await this.request({\n      method: OPENLOGIN_METHOD.LOGIN,\n      allowedInteractions: [UX_MODE.REDIRECT, UX_MODE.POPUP],\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      params: [loginParams]\n    });\n    this.state.privKey = res.privKey;\n\n    if (res.store) {\n      this._syncState(res);\n    } else if (this.state.privKey && this.state.support3PC) {\n      this._syncState(await this._getData());\n    }\n\n    return {\n      privKey: this.privKey\n    };\n  }\n\n  async logout() {\n    let logoutParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const params = {}; // defaults\n\n    params.redirectUrl = this.state.redirectUrl;\n    params._clientId = this.state.clientId;\n\n    if (logoutParams.clientId) {\n      params._clientId = logoutParams.clientId;\n    }\n\n    if (logoutParams.fastLogin !== undefined) {\n      params.fastLogin = logoutParams.fastLogin;\n    }\n\n    if (logoutParams.redirectUrl !== undefined) {\n      params.redirectUrl = logoutParams.redirectUrl;\n    }\n\n    const res = await this.request({\n      method: OPENLOGIN_METHOD.LOGOUT,\n      params: [params],\n      startUrl: this.state.startUrl,\n      popupUrl: this.state.popupUrl,\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC, ALLOWED_INTERACTIONS.POPUP, ALLOWED_INTERACTIONS.REDIRECT]\n    });\n    this.state.privKey = \"\"; // if (!params.fastLogin) this.state.store.set(\"touchIDPreference\", \"disabled\");\n\n    return res;\n  }\n\n  async request(args) {\n    var _params$0$redirectUrl;\n\n    const pid = randomId();\n    let {\n      params\n    } = args; // Note: _origin is added later in postMessageStream for jrpc requests\n    // do not add it here since its used for checking postMessage constraints\n\n    const session = {};\n    if (params.length !== 1) throw new Error(\"request params array should have only one element\");\n    const {\n      startUrl,\n      popupUrl,\n      method,\n      allowedInteractions\n    } = args;\n    if (allowedInteractions.length === 0) throw new Error(\"no allowed interactions\");\n\n    if (this.state.clientId) {\n      session._clientId = this.state.clientId;\n    }\n\n    if (this.privKey) {\n      const userData = {\n        clientId: session._clientId,\n        timestamp: Date.now().toString()\n      };\n      const sig = await sign(Buffer.from(this.privKey, \"hex\"), Buffer.from(keccak(\"keccak256\").update(JSON.stringify(userData)).digest(\"hex\"), \"hex\"));\n      session._user = getPublic(Buffer.from(this.privKey, \"hex\")).toString(\"hex\");\n      session._userSig = base64url.encode(sig);\n      session._userData = userData;\n    }\n\n    session._originData = this.state.originData;\n    session._whiteLabelData = this.state.whiteLabel;\n    session._loginConfig = this.state.loginConfig; // add in session data (allow overrides)\n\n    params = [_objectSpread(_objectSpread({}, session), params[0])]; // use JRPC where possible\n\n    if (this.state.support3PC && allowedInteractions.includes(ALLOWED_INTERACTIONS.JRPC)) {\n      return this._jrpcRequest({\n        method,\n        params\n      });\n    } // set origin\n\n\n    params[0]._origin = new URL((_params$0$redirectUrl = params[0].redirectUrl) !== null && _params$0$redirectUrl !== void 0 ? _params$0$redirectUrl : this.state.redirectUrl).origin; // preset params\n\n    if (this.state.support3PC) {\n      // set params first if 3PC supported\n      await this._setPIDData(pid, params); // eslint-disable-next-line require-atomic-updates\n\n      params = [{}];\n    }\n\n    if (!startUrl || !popupUrl) {\n      throw new Error(\"no url for redirect / popup flow\");\n    } // method and pid are always in URL hash params\n    // convert params from JSON to base64\n\n\n    if (this.state.uxMode === UX_MODE.REDIRECT) {\n      // if redirects preferred, check for redirect flows first, then check for popup flow\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n        // give time for synchronous methods to complete before redirect\n        setTimeout(() => {\n          window.location.href = constructURL({\n            baseURL: startUrl,\n            hash: {\n              b64Params: jsonToBase64(params[0]),\n              _pid: pid,\n              _method: method\n            }\n          });\n        }, 50);\n        return {};\n      }\n\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n        const u = new URL(constructURL({\n          baseURL: popupUrl,\n          hash: {\n            b64Params: jsonToBase64(params[0]),\n            _pid: pid,\n            _method: method\n          }\n        }));\n        const windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n        return awaitReq(pid, windowRef);\n      }\n    } else {\n      // if popups preferred, check for popup flows first, then check for redirect flow\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.POPUP)) {\n        const u = new URL(constructURL({\n          baseURL: popupUrl,\n          hash: {\n            b64Params: jsonToBase64(params[0]),\n            _pid: pid,\n            _method: method\n          }\n        }));\n        const windowRef = window.open(u.toString(), \"_blank\", getPopupFeatures());\n        return awaitReq(pid, windowRef);\n      }\n\n      if (allowedInteractions.includes(ALLOWED_INTERACTIONS.REDIRECT)) {\n        // give time for synchronous methods to complete before redirect\n        setTimeout(() => {\n          window.location.href = constructURL({\n            baseURL: startUrl,\n            hash: {\n              b64Params: jsonToBase64(params[0]),\n              _pid: pid,\n              _method: method\n            }\n          });\n        }, 50);\n        return null;\n      }\n    }\n\n    throw new Error(\"no matching allowed interactions\");\n  }\n\n  async _jrpcRequest(args) {\n    // await this.initialized;\n    if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n      throw new Error(\"invalid request args\");\n    }\n\n    const {\n      method,\n      params\n    } = args;\n\n    if (typeof method !== \"string\" || method.length === 0) {\n      throw new Error(\"invalid request method\");\n    }\n\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error(\"invalid request params\");\n    }\n\n    if (params.length === 0) {\n      params.push({});\n    }\n\n    return new Promise((resolve, reject) => {\n      this.provider._rpcRequest({\n        method,\n        params\n      }, getRpcPromiseCallback(resolve, reject));\n    });\n  }\n\n  async _check3PCSupport() {\n    return this._jrpcRequest({\n      method: OPENLOGIN_METHOD.CHECK_3PC_SUPPORT,\n      params: [{\n        _originData: this.state.originData\n      }]\n    });\n  }\n\n  async _setPIDData(pid, data) {\n    await this.request({\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n      method: OPENLOGIN_METHOD.SET_PID_DATA,\n      params: [{\n        pid,\n        data: data[0]\n      }]\n    });\n  }\n\n  async _getData() {\n    return this.request({\n      allowedInteractions: [ALLOWED_INTERACTIONS.JRPC],\n      method: OPENLOGIN_METHOD.GET_DATA,\n      params: [{}]\n    });\n  }\n\n  _syncState(newState) {\n    if (newState.store) {\n      if (typeof newState.store !== \"object\") {\n        throw new Error(\"expected store to be an object\");\n      }\n\n      Object.keys(newState.store).forEach(key => {\n        // if privKey is available then user is not logged out, but in popup mode store info is not available.\n        // so we don't want to overwrite the local store if privKey is available\n        // and if latest iframe store data is not available\n        if (newState.privKey) {\n          if (newState.store[key]) {\n            this.state.store.set(key, newState.store[key]);\n          }\n        } else {\n          this.state.store.set(key, newState.store[key]);\n        }\n      });\n    }\n\n    const {\n      store\n    } = this.state;\n    this.state = _objectSpread(_objectSpread(_objectSpread({}, this.state), newState), {}, {\n      store\n    });\n  }\n\n  async _modal(params) {\n    return new Promise((resolve, reject) => {\n      this.modal._prompt(this.state.clientId, this.state.whiteLabel, this.state.loginConfig, async chunk => {\n        if (chunk.cancel) {\n          reject(new Error(\"user canceled login\"));\n        } else {\n          try {\n            const selectedLoginResponse = await this._selectedLogin(merge(params, chunk));\n            resolve(selectedLoginResponse);\n          } catch (error) {\n            reject(error);\n          }\n        }\n      });\n    });\n  }\n\n  async _cleanup() {\n    await this.modal.cleanup();\n    this.provider.cleanup();\n  }\n\n  async encrypt(message, privateKey) {\n    let privKey = privateKey;\n\n    if (!privKey) {\n      privKey = this.privKey;\n    } // validations\n\n\n    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n      if (privKey === \"\" || privKey === undefined) {\n        throw new Error(\"private key cannot be empty\");\n      } else {\n        throw new Error(\"invalid private key in encrypt\");\n      }\n    }\n\n    return encrypt(getPublic(Buffer.from(privKey, \"hex\")), message);\n  }\n\n  async decrypt(ciphertext, privateKey) {\n    let privKey = privateKey;\n\n    if (!privKey) {\n      privKey = this.privKey;\n    } // validations\n\n\n    if (!/^[0-9a-fA-f]{64}$/.exec(privKey)) {\n      if (privKey === \"\" || privKey === undefined) {\n        throw new Error(\"private key cannot be empty\");\n      } else {\n        throw new Error(\"invalid private key in decrypt\");\n      }\n    }\n\n    return decrypt(Buffer.from(privKey, \"hex\"), ciphertext);\n  }\n\n  async getUserInfo() {\n    if (this.privKey) {\n      const storeData = this.state.store.getStore();\n      const userInfo = {\n        email: storeData.email || \"\",\n        name: storeData.name || \"\",\n        profileImage: storeData.profileImage || \"\",\n        aggregateVerifier: storeData.aggregateVerifier || \"\",\n        verifier: storeData.verifier || \"\",\n        verifierId: storeData.verifierId || \"\",\n        typeOfLogin: storeData.typeOfLogin || \"\",\n        dappShare: storeData.dappShare || \"\"\n      };\n      return userInfo;\n    }\n\n    throw new Error(\"user should be logged in to fetch userInfo\");\n  }\n\n  async getEncodedLoginUrl(loginParams) {\n    const {\n      redirectUrl\n    } = loginParams;\n    const {\n      clientId\n    } = this.state;\n\n    if (!this.state.originData[origin]) {\n      await this.updateOriginData();\n    }\n\n    const dataObject = _objectSpread({\n      _clientId: clientId,\n      _origin: new URL(redirectUrl).origin,\n      _originData: this.state.originData,\n      redirectUrl\n    }, loginParams);\n\n    const b64Params = jsonToBase64(dataObject);\n    const hashParams = {\n      b64Params,\n      _method: \"openlogin_login\"\n    };\n    return constructURL({\n      baseURL: \"\".concat(this.state.iframeUrl, \"/start\"),\n      hash: hashParams\n    });\n  }\n\n}\n\nexport { ALLOWED_INTERACTIONS, LOGIN_PROVIDER, MFA_LEVELS, OPENLOGIN_METHOD, OPENLOGIN_NETWORK, OpenLoginStore, Provider, UX_MODE, awaitReq, constructURL, OpenLogin as default, documentReady, getHashQueryParams, getPopupFeatures, htmlToElement, localStorageAvailable, log as loglevel, modalDOMElementID, preloadIframe, sessionStorageAvailable, storageAvailable, storeKey, whitelistUrl };\n//# sourceMappingURL=openlogin.esm.js.map\n",null,null,null,null,null,null,"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { Duplex } from 'readable-stream';\nimport { randomId } from '@toruslabs/openlogin-utils';\nimport { EventEmitter } from 'events';\nimport stringify from 'fast-safe-stringify';\nimport eos from 'end-of-stream';\nimport once from 'once';\nimport pump from 'pump';\n\nfunction noop() {\n  return undefined;\n}\n\nconst SYN = \"SYN\";\nconst ACK = \"ACK\";\nconst BRK = \"BRK\";\nclass BasePostMessageStream extends Duplex {\n  constructor(_ref) {\n    let {\n      name,\n      target,\n      targetWindow = window,\n      targetOrigin = \"*\"\n    } = _ref;\n    super({\n      objectMode: true\n    });\n\n    _defineProperty(this, \"_init\", void 0);\n\n    _defineProperty(this, \"_haveSyn\", void 0);\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_target\", void 0);\n\n    _defineProperty(this, \"_targetWindow\", void 0);\n\n    _defineProperty(this, \"_targetOrigin\", void 0);\n\n    _defineProperty(this, \"_onMessage\", void 0);\n\n    _defineProperty(this, \"_synIntervalId\", void 0);\n\n    if (!name || !target) {\n      throw new Error(\"Invalid input.\");\n    }\n\n    this._init = false;\n    this._haveSyn = false;\n    this._name = name;\n    this._target = target; // target origin\n\n    this._targetWindow = targetWindow;\n    this._targetOrigin = targetOrigin;\n    this._onMessage = this.onMessage.bind(this);\n    this._synIntervalId = null;\n    window.addEventListener(\"message\", this._onMessage, false);\n\n    this._handShake();\n  }\n\n  _break() {\n    this.cork();\n\n    this._write(BRK, null, noop);\n\n    this._haveSyn = false;\n    this._init = false;\n  }\n\n  _handShake() {\n    this._write(SYN, null, noop);\n\n    this.cork();\n  }\n\n  _onData(data) {\n    if (!this._init) {\n      // listen for handshake\n      if (data === SYN) {\n        this._haveSyn = true;\n\n        this._write(ACK, null, noop);\n      } else if (data === ACK) {\n        this._init = true;\n\n        if (!this._haveSyn) {\n          this._write(ACK, null, noop);\n        }\n\n        this.uncork();\n      }\n    } else if (data === BRK) {\n      this._break();\n    } else {\n      // forward message\n      try {\n        this.push(data);\n      } catch (err) {\n        this.emit(\"error\", err);\n      }\n    }\n  }\n\n  _postMessage(data) {\n    const originConstraint = this._targetOrigin;\n\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n\n  onMessage(event) {\n    const message = event.data; // validate message\n\n    if (this._targetOrigin !== \"*\" && event.origin !== this._targetOrigin || event.source !== this._targetWindow || typeof message !== \"object\" || message.target !== this._name || !message.data) {\n      return;\n    }\n\n    this._onData(message.data);\n  }\n\n  _read() {\n    return undefined;\n  }\n\n  _write(data, _, cb) {\n    this._postMessage(data);\n\n    cb();\n  }\n\n  _destroy() {\n    window.removeEventListener(\"message\", this._onMessage, false);\n  }\n\n}\n\nfunction safeApply(handler, context, args) {\n  try {\n    Reflect.apply(handler, context, args);\n  } catch (err) {\n    // Throw error after timeout so as not to interrupt the stack\n    setTimeout(() => {\n      throw err;\n    });\n  }\n}\n\nfunction arrayClone(arr) {\n  const n = arr.length;\n  const copy = new Array(n);\n\n  for (let i = 0; i < n; i += 1) {\n    copy[i] = arr[i];\n  }\n\n  return copy;\n}\n\nclass SafeEventEmitter extends EventEmitter {\n  emit(type) {\n    let doError = type === \"error\";\n    const events = this._events;\n\n    if (events !== undefined) {\n      doError = doError && events.error === undefined;\n    } else if (!doError) {\n      return false;\n    } // If there is no 'error' event listener then throw.\n\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (doError) {\n      let er;\n\n      if (args.length > 0) {\n        [er] = args;\n      }\n\n      if (er instanceof Error) {\n        // Note: The comments on the `throw` lines are intentional, they show\n        // up in Node's output if this results in an unhandled exception.\n        throw er; // Unhandled 'error' event\n      } // At least give some kind of context to the user\n\n\n      const err = new Error(\"Unhandled error.\".concat(er ? \" (\".concat(er.message, \")\") : \"\"));\n      err.context = er;\n      throw err; // Unhandled 'error' event\n    }\n\n    const handler = events[type];\n\n    if (handler === undefined) {\n      return false;\n    }\n\n    if (typeof handler === \"function\") {\n      safeApply(handler, this, args);\n    } else {\n      const len = handler.length;\n      const listeners = arrayClone(handler);\n\n      for (let i = 0; i < len; i += 1) {\n        safeApply(listeners[i], this, args);\n      }\n    }\n\n    return true;\n  }\n\n}\n\nclass SerializableError extends Error {\n  constructor(_ref) {\n    let {\n      code,\n      message,\n      data\n    } = _ref;\n\n    if (!Number.isInteger(code)) {\n      throw new Error(\"code must be an integer\");\n    }\n\n    if (!message || typeof message !== \"string\") {\n      throw new Error(\"message must be string\");\n    }\n\n    super(message);\n\n    _defineProperty(this, \"code\", void 0);\n\n    _defineProperty(this, \"data\", void 0);\n\n    this.code = code;\n\n    if (data !== undefined) {\n      this.data = data;\n    }\n  }\n\n  toString() {\n    return stringify({\n      code: this.code,\n      message: this.message,\n      data: this.data,\n      stack: this.stack\n    });\n  }\n\n}\n\nfunction serializeError(error) {\n  return error.toString();\n}\nconst getRpcPromiseCallback = function (resolve, reject) {\n  let unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return (error, response) => {\n    if (error || response.error) {\n      reject(error || response.error);\n    } else if (!unwrapResult || Array.isArray(response)) {\n      resolve(response);\n    } else {\n      resolve(response.result);\n    }\n  };\n};\nfunction createErrorMiddleware(log) {\n  return (req, res, next, end) => {\n    try {\n      // json-rpc-engine will terminate the request when it notices this error\n      if (typeof req.method !== \"string\" || !req.method) {\n        res.error = new SerializableError({\n          code: -32603,\n          message: \"invalid method\"\n        });\n        end();\n        return;\n      }\n\n      next(done => {\n        const {\n          error\n        } = res;\n\n        if (!error) {\n          return done();\n        }\n\n        log.error(\"OpenLogin - RPC Error: \".concat(error.message), error);\n        return done();\n      });\n    } catch (error) {\n      log.error(\"OpenLogin - RPC Error thrown: \".concat(error.message), error);\n      res.error = new SerializableError({\n        code: -32603,\n        message: error.message\n      });\n      end();\n    }\n  };\n}\nfunction createStreamMiddleware() {\n  const idMap = {};\n\n  function readNoop() {\n    return false;\n  }\n\n  const events = new SafeEventEmitter();\n\n  function processResponse(res) {\n    const context = idMap[res.id];\n\n    if (!context) {\n      throw new Error(\"StreamMiddleware - Unknown response id \\\"\".concat(res.id, \"\\\"\"));\n    }\n\n    delete idMap[res.id]; // copy whole res onto original res\n\n    Object.assign(context.res, res); // run callback on empty stack,\n    // prevent internal stream-handler from catching errors\n\n    setTimeout(context.end);\n  }\n\n  function processNotification(res) {\n    events.emit(\"notification\", res);\n  }\n\n  function processMessage(res, _encoding, cb) {\n    let err;\n\n    try {\n      const isNotification = !res.id;\n\n      if (isNotification) {\n        processNotification(res);\n      } else {\n        processResponse(res);\n      }\n    } catch (_err) {\n      err = _err;\n    } // continue processing stream\n\n\n    cb(err);\n  }\n\n  const stream = new Duplex({\n    objectMode: true,\n    read: readNoop,\n    write: processMessage\n  });\n\n  const middleware = (req, res, next, end) => {\n    // write req to stream\n    stream.push(req); // register request on id map\n\n    idMap[req.id] = {\n      req,\n      res,\n      next,\n      end\n    };\n  };\n\n  return {\n    events,\n    middleware,\n    stream\n  };\n}\nfunction createScaffoldMiddleware(handlers) {\n  return (req, res, next, end) => {\n    const handler = handlers[req.method]; // if no handler, return\n\n    if (handler === undefined) {\n      return next();\n    } // if handler is fn, call as middleware\n\n\n    if (typeof handler === \"function\") {\n      return handler(req, res, next, end);\n    } // if handler is some other value, use as result\n\n\n    res.result = handler;\n    return end();\n  };\n}\nfunction createIdRemapMiddleware() {\n  return (req, res, next, _end) => {\n    const originalId = req.id;\n    const newId = randomId();\n    req.id = newId;\n    res.id = newId;\n    next(done => {\n      req.id = originalId;\n      res.id = originalId;\n      done();\n    });\n  };\n}\nfunction createLoggerMiddleware(logger) {\n  return (req, res, next, _) => {\n    logger.debug(\"REQ\", req, \"RES\", res);\n    next();\n  };\n}\nfunction createAsyncMiddleware(asyncMiddleware) {\n  return async (req, res, next, end) => {\n    // nextPromise is the key to the implementation\n    // it is resolved by the return handler passed to the\n    // \"next\" function\n    let resolveNextPromise;\n    const nextPromise = new Promise(resolve => {\n      resolveNextPromise = resolve;\n    });\n    let returnHandlerCallback = null;\n    let nextWasCalled = false; // This will be called by the consumer's async middleware.\n\n    const asyncNext = async () => {\n      nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,\n      // the consumer's async middleware will resume executing.\n\n      next(runReturnHandlersCallback => {\n        // This callback comes from JRPCEngine._runReturnHandlers\n        returnHandlerCallback = runReturnHandlersCallback;\n        resolveNextPromise();\n      });\n      await nextPromise;\n    };\n\n    try {\n      await asyncMiddleware(req, res, asyncNext);\n\n      if (nextWasCalled) {\n        await nextPromise; // we must wait until the return handler is called\n\n        returnHandlerCallback(null);\n      } else {\n        end(null);\n      }\n    } catch (error) {\n      if (returnHandlerCallback) {\n        returnHandlerCallback(error);\n      } else {\n        end(error);\n      }\n    }\n  };\n}\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\n\nclass JRPCEngine extends SafeEventEmitter {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"_middleware\", void 0);\n\n    this._middleware = [];\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n\n\n  static async _runAllMiddleware(req, res, middlewareStack) {\n    const returnHandlers = [];\n    let error = null;\n    let isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n\n    for (const middleware of middlewareStack) {\n      [error, isComplete] = await JRPCEngine._runMiddleware(req, res, middleware, returnHandlers);\n\n      if (isComplete) {\n        break;\n      }\n    }\n\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n\n\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n\n        if (error) {\n          res.error = serializeError(error);\n        } // True indicates that the request should end\n\n\n        resolve([error, true]);\n      };\n\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== \"function\") {\n              end(new SerializableError({\n                code: -32603,\n                message: \"JRPCEngine: 'next' return handlers must be functions\"\n              }));\n            }\n\n            returnHandlers.push(returnHandler);\n          } // False indicates that the request should not end\n\n\n          resolve([null, false]);\n        }\n      };\n\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n\n\n  static async _runReturnHandlers(handlers) {\n    for (const handler of handlers) {\n      await new Promise((resolve, reject) => {\n        handler(err => err ? reject(err) : resolve());\n      });\n    }\n  }\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n\n\n  static _checkForCompletion(req, res, isComplete) {\n    if (!(\"result\" in res) && !(\"error\" in res)) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Response has no error or result for request\"\n      });\n    }\n\n    if (!isComplete) {\n      throw new SerializableError({\n        code: -32603,\n        message: \"Nothing ended request\"\n      });\n    }\n  }\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n\n\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n\n  handle(req, cb) {\n    if (cb && typeof cb !== \"function\") {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n\n      return this._handleBatch(req);\n    }\n\n    if (cb) {\n      return this._handle(req, cb);\n    }\n\n    return this._promiseHandle(req);\n  }\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n\n\n  asMiddleware() {\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware);\n\n        if (isComplete) {\n          await JRPCEngine._runReturnHandlers(returnHandlers);\n          return end(middlewareError);\n        }\n\n        return next(async handlerCallback => {\n          try {\n            await JRPCEngine._runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n\n  async _handleBatch(reqs, cb) {\n    // The order here is important\n    try {\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = await Promise.all( // 1. Begin executing each request in the order received\n      reqs.map(this._promiseHandle.bind(this))); // 3. Return batch response\n\n      if (cb) {\n        return cb(null, responses);\n      }\n\n      return responses;\n    } catch (error) {\n      if (cb) {\n        return cb(error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * A promise-wrapped _handle.\n   */\n\n\n  _promiseHandle(req) {\n    return new Promise(resolve => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n\n\n  async _handle(callerReq, cb) {\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== \"object\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"request must be plain object\"\n      });\n      return cb(error, {\n        id: undefined,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n\n    if (typeof callerReq.method !== \"string\") {\n      const error = new SerializableError({\n        code: -32603,\n        message: \"method must be string\"\n      });\n      return cb(error, {\n        id: callerReq.id,\n        jsonrpc: \"2.0\",\n        error\n      });\n    }\n\n    const req = _objectSpread$1({}, callerReq);\n\n    const res = {\n      id: req.id,\n      jsonrpc: req.jsonrpc\n    };\n    let error = null;\n\n    try {\n      await this._processRequest(req, res);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n\n      if (!res.error) {\n        res.error = serializeError(error);\n      }\n    }\n\n    return cb(error, res);\n  }\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n\n\n  async _processRequest(req, res) {\n    const [error, isComplete, returnHandlers] = await JRPCEngine._runAllMiddleware(req, res, this._middleware); // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n\n    JRPCEngine._checkForCompletion(req, res, isComplete); // The return handlers should run even if an error was encountered during\n    // middleware processing.\n\n\n    await JRPCEngine._runReturnHandlers(returnHandlers); // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n\n    if (error) {\n      throw error;\n    }\n  }\n\n}\nfunction mergeMiddleware(middlewareStack) {\n  const engine = new JRPCEngine();\n  middlewareStack.forEach(middleware => engine.push(middleware));\n  return engine.asMiddleware();\n}\nfunction createEngineStream(opts) {\n  if (!opts || !opts.engine) {\n    throw new Error(\"Missing engine parameter!\");\n  }\n\n  const {\n    engine\n  } = opts; // eslint-disable-next-line prefer-const\n\n  let stream;\n\n  function read() {\n    return undefined;\n  }\n\n  function write(req, _encoding, cb) {\n    engine.handle(req, (_err, res) => {\n      stream.push(res);\n    });\n    cb();\n  }\n\n  stream = new Duplex({\n    objectMode: true,\n    read,\n    write\n  }); // forward notifications\n\n  if (engine.on) {\n    engine.on(\"notification\", message => {\n      stream.push(message);\n    });\n  }\n\n  return stream;\n}\n\nclass Substream extends Duplex {\n  constructor(_ref) {\n    let {\n      parent,\n      name\n    } = _ref;\n    super({\n      objectMode: true\n    });\n\n    _defineProperty(this, \"_parent\", void 0);\n\n    _defineProperty(this, \"_name\", void 0);\n\n    this._parent = parent;\n    this._name = name;\n  }\n  /**\n   * Explicitly sets read operations to a no-op.\n   */\n\n\n  _read() {\n    return undefined;\n  }\n  /**\n   * Called when data should be written to this writable stream.\n   *\n   * @param chunk - Arbitrary object to write\n   * @param encoding - Encoding to use when writing payload\n   * @param callback - Called when writing is complete or an error occurs\n   */\n\n\n  _write(chunk, _encoding, callback) {\n    this._parent.push({\n      name: this._name,\n      data: chunk\n    });\n\n    callback();\n  }\n\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst IGNORE_SUBSTREAM = Symbol(\"IGNORE_SUBSTREAM\");\nclass ObjectMultiplex extends Duplex {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(_objectSpread(_objectSpread({}, opts), {}, {\n      objectMode: true\n    }));\n\n    _defineProperty(this, \"_substreams\", void 0);\n\n    _defineProperty(this, \"getStream\", void 0);\n\n    this._substreams = {};\n  }\n\n  createStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n\n    if (this._substreams[name]) {\n      throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n    } // create substream\n\n\n    const substream = new Substream({\n      parent: this,\n      name\n    });\n    this._substreams[name] = substream; // listen for parent stream to end\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    anyStreamEnd(this, _error => substream.destroy(_error || undefined));\n    return substream;\n  } // ignore streams (dont display orphaned data warning)\n\n\n  ignoreStream(name) {\n    // validate name\n    if (!name) {\n      throw new Error(\"ObjectMultiplex - name must not be empty\");\n    }\n\n    if (this._substreams[name]) {\n      throw new Error(\"ObjectMultiplex - Substream for name \\\"\".concat(name, \"\\\" already exists\"));\n    } // set\n\n\n    this._substreams[name] = IGNORE_SUBSTREAM;\n  }\n\n  _read() {\n    return undefined;\n  }\n\n  _write(chunk, _encoding, callback) {\n    const {\n      name,\n      data\n    } = chunk;\n\n    if (!name) {\n      window.console.warn(\"ObjectMultiplex - malformed chunk without name \\\"\".concat(chunk, \"\\\"\"));\n      return callback();\n    } // get corresponding substream\n\n\n    const substream = this._substreams[name];\n\n    if (!substream) {\n      window.console.warn(\"ObjectMultiplex - orphaned data for stream \\\"\".concat(name, \"\\\"\"));\n      return callback();\n    } // push data into substream\n\n\n    if (substream !== IGNORE_SUBSTREAM) {\n      substream.push(data);\n    }\n\n    return callback();\n  }\n\n} // util\n\nfunction anyStreamEnd(stream, _cb) {\n  const cb = once(_cb);\n  eos(stream, {\n    readable: false\n  }, cb);\n  eos(stream, {\n    writable: false\n  }, cb);\n}\n\nfunction setupMultiplex(stream) {\n  const mux = new ObjectMultiplex();\n\n  mux.getStream = function streamHelper(name) {\n    if (this._substreams[name]) {\n      return this._substreams[name];\n    }\n\n    return this.createStream(name);\n  };\n\n  pump(stream, mux, stream, err => {\n    if (err) window.console.error(err);\n  });\n  return mux;\n}\n\nclass PostMessageStream extends BasePostMessageStream {\n  _postMessage(data) {\n    let originConstraint = this._targetOrigin;\n\n    if (typeof data === \"object\") {\n      const dataObj = data;\n\n      if (typeof dataObj.data === \"object\") {\n        const dataObjData = dataObj.data;\n\n        if (Array.isArray(dataObjData.params) && dataObjData.params.length > 0) {\n          const dataObjDataParam = dataObjData.params[0];\n\n          if (dataObjDataParam._origin) {\n            originConstraint = dataObjDataParam._origin;\n          } // add a constraint for the response\n\n\n          dataObjDataParam._origin = window.location.origin;\n        }\n      }\n    }\n\n    this._targetWindow.postMessage({\n      target: this._target,\n      data\n    }, originConstraint);\n  }\n\n}\n\nexport { BasePostMessageStream, IGNORE_SUBSTREAM, JRPCEngine, ObjectMultiplex, PostMessageStream, SafeEventEmitter, SerializableError, Substream, createAsyncMiddleware, createEngineStream, createErrorMiddleware, createIdRemapMiddleware, createLoggerMiddleware, createScaffoldMiddleware, createStreamMiddleware, getRpcPromiseCallback, mergeMiddleware, serializeError, setupMultiplex };\n//# sourceMappingURL=openloginJrpc.esm.js.map\n",null,null,null,null,null,null,null,"'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('util'),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();","'use strict';\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = require('./end-of-stream');\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\nrequire('inherits')(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n'use strict';\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = require('../../../errors').codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;","import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams } from '@toruslabs/openlogin';\nimport { getChainConfig, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, log, WalletInitializationError, ADAPTER_EVENTS, WalletLoginError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport merge from 'lodash.merge';\n\nconst getOpenloginDefaultOptions = (chainNamespace, chainId) => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : null,\n    loginSettings: {\n      relogin: true\n    }\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass OpenloginAdapter extends BaseAdapter {\n  constructor(params) {\n    var _params$chainConfig, _params$chainConfig2, _params$chainConfig3;\n\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n\n    _defineProperty(this, \"openloginInstance\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"openloginOptions\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"privKeyProvider\", null);\n\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);\n    this.openloginOptions = _objectSpread(_objectSpread({\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, defaultOptions.adapterSettings), params.adapterSettings || {});\n    this.loginSettings = _objectSpread(_objectSpread({}, defaultOptions.loginSettings), params.loginSettings); // if no chainNamespace is passed then chain config should be set before calling init\n\n    if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {\n      var _params$chainConfig4;\n\n      this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n\n      if (!this.chainConfig.rpcTarget) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  get provider() {\n    var _this$privKeyProvider;\n\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    var _this$openloginOption;\n\n    super.checkInitializationRequirements();\n    if (!((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId)) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT) {\n      const redirectResult = getHashQueryParams();\n\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params) {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n\n  setAdapterSettings(adapterSettings) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);\n  } // should be called only before initialization.\n\n\n  setChainConfig(customChainConfig) {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n\n  async connectWithProvider(params) {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else {\n      throw new Error(\"Invalid chainNamespace: \".concat(this.currentChainNamespace, \" found while connecting to wallet\"));\n    } // if not logged in then login\n\n\n    if (!this.openloginInstance.privKey && params) {\n      var _params$extraLoginOpt;\n\n      await this.openloginInstance.login(merge(this.loginSettings, {\n        loginProvider: params.loginProvider\n      }, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt = params.extraLoginOptions) === null || _params$extraLoginOpt === void 0 ? void 0 : _params$extraLoginOpt.login_hint)\n        })\n      }));\n    }\n\n    let finalPrivKey = this.openloginInstance.privKey;\n\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: !params\n      });\n    }\n  }\n\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };\n//# sourceMappingURL=openloginAdapter.esm.js.map\n",null],"sourceRoot":""}